============================================================================================================
                            저장시간 : 2021-03-04 오전 10:42:58 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 컴파일 환경 - Release + x86
// 강의저장 함수 save 만들고 파일분리하기!
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// google coding convention (구글 코딩 스타일) 아랫줄 :)
using namespace std;

  
int main()
{
	save("2021STL.cpp");
	save("save.cpp");
	save("save.h");
}	



============================================================================================================
                            저장시간 : 2021-03-04 오전 10:42:58 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// save.cpp 강의록에 파일을 덧붙여 저장한다.
//
// 2021. 3 파일이름을 주면 강의록에 덧붙여 저장한다.
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

void save(std::string_view file_name)
{
	// 저장할 파일 정보를 출력한다.
	std::cout << "저장할 파일: " << file_name << ", 크기: " << std::filesystem::file_size(file_name) << std::endl;

	// 읽을 파일을 연다.
	std::ifstream in(file_name);
	// 저장할 파일을 연다.
	std::ofstream out("2021_1학기_STL(화78,목23)_강의저장.txt", std::ios::app);

	out << std::endl << std::endl;

	// 출력스트림을 한국 기준으로!
	out.imbue(std::locale("korean"));

	// 저장한 시간 정보를 파일에 기록한다.
	time_t t = time(nullptr);
	out << "============================================================================================================" << std::endl;
	out << "                            저장시간 : " << std::put_time(localtime(&t), "%c %A") << std::endl;
	out << "============================================================================================================" << std::endl;

	// 입력파일에서 한글자을 읽어 출력파일에 쓴다.
	int c;
	while ((c = in.get()) != EOF)
		out.put(c);
}

============================================================================================================
                            저장시간 : 2021-03-04 오전 10:42:58 목요일
============================================================================================================
#include <string_view>
#include <filesystem>
#include <fstream>
#include <ctime>


void save(std::string_view file_name);

============================================================================================================
                            저장시간 : 2021-03-04 오전 11:06:35 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// google coding convention (구글 코딩 스타일) 아랫줄 :)
using namespace std;

// [문제] main()을 바꾸지 말고 해결할것
// C는 클래스다

class C {
	int num;
	friend ostream& operator<<(ostream& os, const C& c);
public:
	C(int num) : num(num) {};
};


void change(C& a, C& b)
{
	C temp{ b };
	b = a;
	a = temp;
}

ostream& operator<<(ostream& os, const C& c)
{
	os << c.num;
	return os;
}

int main()
{
	C a{ 1 };
	C b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;
	save("2021STL.cpp");
}	



============================================================================================================
                            저장시간 : 2021-03-04 오전 11:18:57 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// google coding convention (구글 코딩 스타일) 아랫줄 :)
using namespace std;

// [문제] main()을 바꾸지 말고 해결할것
// C는 클래스다

// Q.레퍼런스는 뭐야? 
// A.이미 존재하는 메모리에 붙히는 별명 :)
//
// Q.모르겟지? ㅋㅋㅋㅋㅋㅋㅋ 
// A.실체가 있을떄만 가능하다네....
// 
// Q. 레퍼런스는 왜써?
// A. 다른지역에 있는 친구를 원격 조정하기 위한 친구
//
// TIP! 레퍼런스는 결국 포인터로 구현됨

class C {
	int num;
	friend ostream& operator<<(ostream& os, const C& c);
public:
	C(int num) : num(num) {};
};


void change(C& a, C& b)
{
	C temp{ b };
	b = a;
	a = temp;
}

ostream& operator<<(ostream& os, const C& c)
{
	os << c.num;
	return os;
}

int main()
{
	C a{ 1 };
	C b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;
	save("2021STL.cpp");
}	



============================================================================================================
                            저장시간 : 2021-03-04 오전 11:42:03 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

using namespace std;

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10개를 만들자
// 1.출력해봐라
// 2.오름차순으로 정렬헤라
// 3.다시 출력해봐라

default_random_engine dre;

int main()
{	
	uniform_int_distribution<> uid;

	int a[10];

	for (int& num : a)
		num = uid(dre);

	for (int d : a)
		cout << d << " ";
	cout << endl;
	save("2021STL.cpp");
}	



============================================================================================================
                            저장시간 : 2021-03-04 오전 11:47:41 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std;

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10개를 만들자
// 1.출력해봐라
// 2.오름차순으로 정렬헤라
// 3.다시 출력해봐라

default_random_engine dre;

int main()
{	
	uniform_int_distribution<> uid(1,1000);

	int a[10];

	for (int& num : a)
		num = uid(dre);

	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "정렬 시작!" << endl;
	sort(begin(a), end(a));

	for (int d : a)
		cout << d << "";
	cout << endl;

	cout << "제일 큰값 : " << end(a) << endl;
	save("2021STL.cpp");
}	



============================================================================================================
                            저장시간 : 2021-03-04 오전 11:47:57 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std;

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10개를 만들자
// 1.출력해봐라
// 2.오름차순으로 정렬헤라
// 3.다시 출력해봐라

default_random_engine dre;

int main()
{	
	uniform_int_distribution<> uid(1,1000);

	int a[10];

	for (int& num : a)
		num = uid(dre);

	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "정렬 시작!" << endl;
	sort(begin(a), end(a));

	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "제일 큰값 : " << end(a) << endl;
	save("2021STL.cpp");
}	



============================================================================================================
                            저장시간 : 2021-03-04 오전 11:48:16 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std;

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10개를 만들자
// 1.출력해봐라
// 2.오름차순으로 정렬헤라
// 3.다시 출력해봐라

default_random_engine dre;

int main()
{	
	uniform_int_distribution<> uid(1,1000);

	int a[10];

	for (int& num : a)
		num = uid(dre);

	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "정렬 시작!" << endl;
	sort(begin(a), end(a));

	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "제일 큰값 : " << a[9] << endl;
	save("2021STL.cpp");
}	



============================================================================================================
                            저장시간 : 2021-03-04 오전 11:55:04 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std;

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10개를 만들자
// 1.출력해봐라
// 2.오름차순으로 정렬헤라
// 3.내림차순도 해봐라
// 4.다시 출력해봐라

default_random_engine dre;

int main()
{
	uniform_int_distribution<> uid{ 1, 1000 };

	int a[10];

	for (int& num : a)
		num = uid(dre);

	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "정렬 시작!" << endl;
//	sort(begin(a), end(a));
	sort(std::begin(a), std::end(a), [](int a, int b) {
		return a > b;
		});
	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "제일 큰값 : " << a[9] << endl;
	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-04 오후 12:02:11 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std;

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10개를 만들자
// 1.출력해봐라
// 2.오름차순으로 정렬헤라
// 3.내림차순도 해봐라
// 4.다시 출력해봐라

default_random_engine dre;

int main()
{
	uniform_int_distribution<> uid{ 1, 1000 };

	int a[10];

	for (int& num : a)
		num = uid(dre);

	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "정렬 시작!" << endl;
//	sort(begin(a), end(a)); // 마지막 3번쨰 인자는 숨겨져있음 알려주면 됨 :) 그럼 내림차순도 된데이~ / 함수로 만들어준다 :)
	sort(begin(a), end(a), [](int a, int b) {
		return a > b; 
		});

	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "제일 큰값 : " << a[9] << endl;
	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-04 오후 12:04:16 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std;

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10개를 만들자
// 1.출력해봐라
// 2.오름차순으로 정렬헤라
// 3.내림차순도 해봐라
// 4.다시 출력해봐라

default_random_engine dre;

bool x(int a, int b)
{
	return a > b;
}

int main()
{
	uniform_int_distribution<> uid{ 1, 1000 };

	int a[10];

	for (int& num : a)
		num = uid(dre);

	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "정렬 시작!" << endl;
//	sort(begin(a), end(a)); // 마지막 3번쨰 인자는 숨겨져있음 알려주면 됨 :) 그럼 내림차순도 된데이~ / 함수로 만들어준다 :)
	sort(begin(a), end(a), x);

	for (int d : a)
		cout << d << " ";
	cout << endl;
	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-04 오후 12:09:31 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std;

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10개를 만들자
// 1.출력해봐라
// 2.오름차순으로 정렬헤라
// 3.내림차순도 해봐라
// 4.다시 출력해봐라

default_random_engine dre;

bool x(int a, int b)
{
	return a > b;
}

int main()
{
	uniform_int_distribution<> uid{ 1, 1000 };

	int a[10];

	for (int& num : a)
		num = uid(dre);

	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "정렬 시작!" << endl;
	int count = 0;
//	sort(begin(a), end(a)); // 마지막 3번쨰 인자는 숨겨져있음 알려주면 됨 :) 그럼 내림차순도 된데이~ / 함수로 만들어준다 :)
	sort(begin(a), end(a), [&count](int a, int b) {
		count++;
		return a > b; 
		});

	for (int d : a)
		cout << d << " ";

	cout << count << endl;
	cout << endl;
	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-04 오후 12:10:21 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std;

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10개를 만들자
// 1.출력해봐라
// 2.오름차순으로 정렬헤라
// 3.내림차순도 해봐라
// 4.다시 출력해봐라

default_random_engine dre;

bool x(int a, int b)
{
	return a > b;
}

int main()
{
	uniform_int_distribution<> uid{ 1, 1000 };

	int a[10];

	for (int& num : a)
		num = uid(dre);

	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "정렬 시작!" << endl;
	int count = 0;
//	sort(begin(a), end(a)); // 마지막 3번쨰 인자는 숨겨져있음 알려주면 됨 :) 그럼 내림차순도 된데이~ / 함수로 만들어준다 :)
	sort(begin(a), end(a), [&count](int a, int b) {
		count++;
		return a > b; 
		});

	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "비교 호출 횟수 - " << count << endl;
	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-04 오후 12:12:10 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std;

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 1000개를 만들자
// 출력해봐라
// 내림차순 정렬 해봐라
// 출력해봐라


default_random_engine dre;

int main()
{
	uniform_int_distribution<> uid;

	int a[1000];

	for (int& num : a)
		num = uid(dre);

	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "정렬 시작!" << endl;
	int count = 0;
//	sort(begin(a), end(a)); // 마지막 3번쨰 인자는 숨겨져있음 알려주면 됨 :) 그럼 내림차순도 된데이~ / 함수로 만들어준다 :)
	sort(begin(a), end(a), [&count](int a, int b) {
		count++;
		return a > b; 
		});

	for (int d : a)
		cout << d << " ";
	cout << endl;

	cout << "비교 호출 횟수 - " << count << endl;
	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-04 오후 12:16:25 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std;

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 1000개를 만들자
// 출력해봐라
// 내림차순 정렬 해봐라
// 출력해봐라


default_random_engine dre;

int main()
{
	uniform_int_distribution<> uid;

	int a[200'000];

	for (int& num : a)
		num = uid(dre);

	//for (int d : a)
	//	cout << d << " ";
	//cout << endl;

	cout << "정렬 시작!" << endl;
	int count = 0;
//	sort(begin(a), end(a)); // 마지막 3번쨰 인자는 숨겨져있음 알려주면 됨 :) 그럼 내림차순도 된데이~ / 함수로 만들어준다 :)
	sort(begin(a), end(a), [&count](int a, int b) {
		count++;
		return a > b; 
		});

	/*for (int d : a)
		cout << d << " ";
	cout << endl;*/

	cout << "첫 원소 : "<< *begin(a) << endl;
	cout << "마지막 원소 : " << *(end(a) - 1) << endl;

	cout << "비교 호출 횟수 - " << count << endl;
	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-04 오후 12:17:30 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std;

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10000000개를 만들자 (천만개임)
// 출력해봐라
// 내림차순 정렬 해봐라
// 출력해봐라


default_random_engine dre;
int a[10000000];

int main()
{
	uniform_int_distribution<> uid;

	for (int& num : a)
		num = uid(dre);

	//for (int d : a)
	//	cout << d << " ";
	//cout << endl;

	cout << "정렬 시작!" << endl;
	int count = 0;
//	sort(begin(a), end(a)); // 마지막 3번쨰 인자는 숨겨져있음 알려주면 됨 :) 그럼 내림차순도 된데이~ / 함수로 만들어준다 :)
	sort(begin(a), end(a), [&count](int a, int b) {
		count++;
		return a > b; 
		});

	/*for (int d : a)
		cout << d << " ";
	cout << endl;*/

	cout << "첫 원소 : "<< *begin(a) << endl;
	cout << "마지막 원소 : " << *(end(a) - 1) << endl;

	cout << "비교 호출 횟수 - " << count << endl;
	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-04 오후 12:18:18 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (1주 2일)
// 이번시간 - 설문
//		      save 파일 분리
//			  정수 데이터 다루기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std;

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10000000개를 만들자 (천만개임)
// 출력해봐라
// 내림차순 정렬 해봐라
// 출력해봐라


default_random_engine dre;
int a[10'000'000];

int main()
{
	uniform_int_distribution<> uid;

	for (int& num : a)
		num = uid(dre);

	//for (int d : a)
	//	cout << d << " ";
	//cout << endl;

	cout << "정렬 시작!" << endl;
	int count = 0;
//	sort(begin(a), end(a)); // 마지막 3번쨰 인자는 숨겨져있음 알려주면 됨 :) 그럼 내림차순도 된데이~ / 함수로 만들어준다 :)
	sort(begin(a), end(a), [&count](int a, int b) {
		count++;
		return a > b; 
		});

	/*for (int d : a)
		cout << d << " ";
	cout << endl;*/

	cout << "첫 원소 : "<< *begin(a) << endl;
	cout << "마지막 원소 : " << *(end(a) - 1) << endl;

	cout << "비교 호출 횟수 - " << count << endl;
	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-09 오후 3:35:36 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (2주 1일)
// 이번시간 - 자료구조 +(iterator) 알고리즘 -> STL
//			- 많은 수의 데이터
//			- 
//			- 많은 수의 정수(<- 애 말고 클래스로 바꿔서...ㅎㅎ) 데이터 다루기 - 정렬
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std;

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10000000개를 만들자 (천만개임)
// 출력해봐라
// 내림차순 정렬 해봐라
// 출력해봐라

// 지역에는 메모리 제한이 있당 :)

default_random_engine dre;
int a[10'000'000];

// 레퍼런스를 쓰는 이유? 참조) 바뀌는걸 허용하지 않는다네... 원격제어를 하기 위해!

int main()
{
	uniform_int_distribution<> uid;

	for (int& num : a)
		num = uid(dre);

	//for (int d : a)
	//	cout << d << " ";
	//cout << endl;

	cout << "정렬 시작!" << endl;
	int count = 0;
//	sort(begin(a), end(a)); // 마지막 3번쨰 인자는 숨겨져있음 알려주면 됨 :) 그럼 내림차순도 된데이~ / 함수로 만들어준다 :)
	sort(begin(a), end(a), [&count](int a, int b) {
		count++;
		return a > b; 
		});

	/*for (int d : a)
		cout << d << " ";
	cout << endl;*/

	cout << "첫 원소 : "<< *begin(a) << endl;
	cout << "마지막 원소 : " << *(end(a) - 1) << endl;

	cout << "비교 호출 횟수 - " << count << endl;
	save("2021STL.cpp");
}










//오늘자 질문 들어올거 예상중….
//
//1.레퍼런스가 뭐야 ?
//?	원격제어를 하기위한 친구
//?(포인터를 이용하지만 포인터처럼 주소값을 바꾼다 같은 짓은 못함) 참조!!!!
//

//2.지역변수와 전역변수의 차이점 :
//

//3.정수 만개를 저장하려면 최소 몆바이트가 필요할까 ?
//?	최소 4만 바이트(근데 아마 4만보단 클거임….이유는 바이너리모드와 텍스트모드의 차이(바이너리모드와 텍스트모드로 파일을 열수 있어….)

//4.반복자 ?
//	-입력 반복자(input iterator) : 현 위치의 원소를 한 번만 읽을 수 있반복자(istream)
//	- 출력 반복자(output iterator) : 현 위치의 원소를 한 번만 쓸 수 있는 반복자(ostream)
//	- 순방향 반복자(forward iterator) : 입력, 출력 반복자 기능에 순방향으로 이동(++)이 가능한 재할당될 수 있는 반복자
//	- 양방향 반복자(bidirectional iterator) : 순방향 반복자 기능에 역방향으로 이동(--)이 가능한 반복자
//	(list, set, mulitset, map, multimap)
//	- 임의 접근 반복자(random access iterator) : 양방향 반복자 기능에 + , -, +=, -=, [] 연산이 가능한 반복자(vector, deque)

//5.스마트포인터… ? / ->객체를 가르키고 있다가 객체가 사라지면 자동으로 풀림
//	?왜쓰냐 ? 자원을 쓰기위해서… 알아서 풀어주니깐 누수 날일 없자나!


============================================================================================================
                            저장시간 : 2021-03-09 오후 3:50:06 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (2주 1일)
// 이번시간 - 자료구조 +(iterator) 알고리즘 -> STL
//			- 많은 수의 데이터
//			- 
//			- 많은 수의 정수(<- 애 말고 클래스로 바꿔서...ㅎㅎ) 데이터 다루기 - 정렬
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10000000개를 만들자 (천만개임)
// 출력해봐라
// 내림차순 정렬 해봐라
// 출력해봐라
// 제일 처음과 마지막 원소만 찍어봐라

// 지역에는 메모리 제한이 있당 :)

default_random_engine dre;
int a[10'000'000]; // 40MB <- int는 4...

// 레퍼런스를 쓰는 이유? 참조) 바뀌는걸 허용하지 않는다네... 원격제어를 하기 위해!

// 지역메모리를 쓰는이유? -> 지역변수도 저장하고 재귀함수일떄도 돌아오고.... 저장할게 은근 많네...?

int main()
{
	uniform_int_distribution<> uid;

	for (int& num : a)
		num = uid(dre);

	//for (int d : a)
	//	cout << d << " ";
	//cout << endl;

	cout << "정렬 시작!" << endl;
	int count = 0;
//	sort(begin(a), end(a)); // 마지막 3번쨰 인자는 숨겨져있음 알려주면 됨 :) 그럼 내림차순도 된데이~ / 함수로 만들어준다 :)
	sort(begin(a), end(a), [&count](int a, int b) {
		// N * logN
		count++;
		return a > b; 
		});

	/*for (int d : a)
		cout << d << " ";
	cout << endl;*/

	// * -> d reference operator

	cout << "첫 원소 : "<< *begin(a) << endl;
	cout << "마지막 원소 : " << *(end(a) - 1) << endl;

	cout << "비교 호출 횟수 - " << count << endl;
	save("2021STL.cpp");
}










//오늘자 질문 들어올거 예상중….
//
//1.레퍼런스가 뭐야 ?
//?	원격제어를 하기위한 친구
//?(포인터를 이용하지만 포인터처럼 주소값을 바꾼다 같은 짓은 못함) 참조!!!!
//

//2.지역변수와 전역변수의 차이점 :
//

//3.정수 만개를 저장하려면 최소 몆바이트가 필요할까 ?
//?	최소 4만 바이트(근데 아마 4만보단 클거임….이유는 바이너리모드와 텍스트모드의 차이(바이너리모드와 텍스트모드로 파일을 열수 있어….)

//4.반복자 ?
//	-입력 반복자(input iterator) : 현 위치의 원소를 한 번만 읽을 수 있반복자(istream)
//	- 출력 반복자(output iterator) : 현 위치의 원소를 한 번만 쓸 수 있는 반복자(ostream)
//	- 순방향 반복자(forward iterator) : 입력, 출력 반복자 기능에 순방향으로 이동(++)이 가능한 재할당될 수 있는 반복자
//	- 양방향 반복자(bidirectional iterator) : 순방향 반복자 기능에 역방향으로 이동(--)이 가능한 반복자
//	(list, set, mulitset, map, multimap)
//	- 임의 접근 반복자(random access iterator) : 양방향 반복자 기능에 + , -, +=, -=, [] 연산이 가능한 반복자(vector, deque)

//5.스마트포인터… ? / ->객체를 가르키고 있다가 객체가 사라지면 자동으로 풀림
//	?왜쓰냐 ? 자원을 쓰기위해서… 알아서 풀어주니깐 누수 날일 없자나!


============================================================================================================
                            저장시간 : 2021-03-09 오후 3:54:21 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (2주 1일)
// 이번시간 - 자료구조 +(iterator) 알고리즘 -> STL
//			- 많은 수의 데이터
//			- 
//			- 많은 수의 정수(<- 애 말고 클래스로 바꿔서...ㅎㅎ) 데이터 다루기 - 정렬
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10000000개를 만들자 (천만개임)
// 출력해봐라
// 내림차순 정렬 해봐라
// 출력해봐라
// 제일 처음과 마지막 원소만 찍어봐라

// 지역에는 메모리 제한이 있당 :)

default_random_engine dre;
int a[10'000'000]; // 40MB <- int는 4...

// 레퍼런스를 쓰는 이유? 참조) 바뀌는걸 허용하지 않는다네... 원격제어를 하기 위해!

// 지역메모리를 쓰는이유? -> 지역변수도 저장하고 재귀함수일떄도 돌아오고.... 저장할게 은근 많네...?


class ABC {
public:
	bool operator()(int a, int b) {
		return a > b;
	};
};

int main()
{
	uniform_int_distribution<> uid;

	for (int& num : a)
		num = uid(dre);

	//for (int d : a)
	//	cout << d << " ";
	//cout << endl;

	cout << "정렬 시작!" << endl;
	int count = 0;
	ABC x;
//	sort(begin(a), end(a)); // 마지막 3번쨰 인자는 숨겨져있음 알려주면 됨 :) 그럼 내림차순도 된데이~ / 함수로 만들어준다 :)
	sort(begin(a), end(a), x);

	// 람다는 그냥 함수보다 빠르다? -> 


	/*for (int d : a)
		cout << d << " ";
	cout << endl;*/

	// * -> d reference operator

	cout << "첫 원소 : "<< *begin(a) << endl;
	cout << "마지막 원소 : " << *(end(a) - 1) << endl;

	cout << "비교 호출 횟수 - " << count << endl;
	save("2021STL.cpp");
}










//오늘자 질문 들어올거 예상중….
//
//1.레퍼런스가 뭐야 ?
//?	원격제어를 하기위한 친구
//?(포인터를 이용하지만 포인터처럼 주소값을 바꾼다 같은 짓은 못함) 참조!!!!
//

//2.지역변수와 전역변수의 차이점 :
//

//3.정수 만개를 저장하려면 최소 몆바이트가 필요할까 ?
//?	최소 4만 바이트(근데 아마 4만보단 클거임….이유는 바이너리모드와 텍스트모드의 차이(바이너리모드와 텍스트모드로 파일을 열수 있어….)

//4.반복자 ?
//	-입력 반복자(input iterator) : 현 위치의 원소를 한 번만 읽을 수 있반복자(istream)
//	- 출력 반복자(output iterator) : 현 위치의 원소를 한 번만 쓸 수 있는 반복자(ostream)
//	- 순방향 반복자(forward iterator) : 입력, 출력 반복자 기능에 순방향으로 이동(++)이 가능한 재할당될 수 있는 반복자
//	- 양방향 반복자(bidirectional iterator) : 순방향 반복자 기능에 역방향으로 이동(--)이 가능한 반복자
//	(list, set, mulitset, map, multimap)
//	- 임의 접근 반복자(random access iterator) : 양방향 반복자 기능에 + , -, +=, -=, [] 연산이 가능한 반복자(vector, deque)

//5.스마트포인터… ? / ->객체를 가르키고 있다가 객체가 사라지면 자동으로 풀림
//	?왜쓰냐 ? 자원을 쓰기위해서… 알아서 풀어주니깐 누수 날일 없자나!


============================================================================================================
                            저장시간 : 2021-03-09 오후 3:56:55 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (2주 1일)
// 이번시간 - 자료구조 +(iterator) 알고리즘 -> STL
//			- 많은 수의 데이터
//			- 
//			- 많은 수의 정수(<- 애 말고 클래스로 바꿔서...ㅎㅎ) 데이터 다루기 - 정렬
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐

// [문제] 임의의 값을 갖는 정수(랜덤엔진과 분포) 10000000개를 만들자 (천만개임)
// 출력해봐라
// 내림차순 정렬 해봐라
// 출력해봐라
// 제일 처음과 마지막 원소만 찍어봐라

// 지역에는 메모리 제한이 있당 :)

default_random_engine dre;
int a[10]; // 40MB <- int는 4...

// 레퍼런스를 쓰는 이유? 참조) 바뀌는걸 허용하지 않는다네... 원격제어를 하기 위해!

// 지역메모리를 쓰는이유? -> 지역변수도 저장하고 재귀함수일떄도 돌아오고.... 저장할게 은근 많네...?


class ABC {
public:
	bool operator()(int a, int b) {
		return a > b;
	};
};

int main()
{
	uniform_int_distribution<> uid;

	for (int& num : a)
		num = uid(dre);

	cout << "정렬 시작!" << endl;
	int count = 0;
	ABC x;
//	sort(begin(a), end(a)); // 마지막 3번쨰 인자는 숨겨져있음 알려주면 됨 :) 그럼 내림차순도 된데이~ / 함수로 만들어준다 :)
	sort(begin(a), end(a), x);

	// 1. 일반함수를 넣을수 있다. (return a > b 해주는 compare 같은 함수)
	// 2. 람다함수를 넣을수 있다. 해봤자나! [](){} <- 이름엄슴 ㅎ
	// 3. 호출가능 타입은 넣을수 있다고 합니다.
	// sort 3번쨰 인자는 호출가능 타입이면 넣을 수 있다!!!!!!!!!!!

	// 람다는 그냥 함수보다 빠르다? -> 이건 찾아봐야할듯...

	// * -> d reference operator

	cout << "첫 원소 : "<< *begin(a) << endl;
	cout << "마지막 원소 : " << *(end(a) - 1) << endl;

	cout << "비교 호출 횟수 - " << count << endl;
	save("2021STL.cpp");
}










//오늘자 질문 들어올거 예상중….
//
//1.레퍼런스가 뭐야 ?
//?	원격제어를 하기위한 친구
//?(포인터를 이용하지만 포인터처럼 주소값을 바꾼다 같은 짓은 못함) 참조!!!!
//

//2.지역변수와 전역변수의 차이점 :
//

//3.정수 만개를 저장하려면 최소 몆바이트가 필요할까 ?
//?	최소 4만 바이트(근데 아마 4만보단 클거임….이유는 바이너리모드와 텍스트모드의 차이(바이너리모드와 텍스트모드로 파일을 열수 있어….)

//4.반복자 ?
//	-입력 반복자(input iterator) : 현 위치의 원소를 한 번만 읽을 수 있반복자(istream)
//	- 출력 반복자(output iterator) : 현 위치의 원소를 한 번만 쓸 수 있는 반복자(ostream)
//	- 순방향 반복자(forward iterator) : 입력, 출력 반복자 기능에 순방향으로 이동(++)이 가능한 재할당될 수 있는 반복자
//	- 양방향 반복자(bidirectional iterator) : 순방향 반복자 기능에 역방향으로 이동(--)이 가능한 반복자
//	(list, set, mulitset, map, multimap)
//	- 임의 접근 반복자(random access iterator) : 양방향 반복자 기능에 + , -, +=, -=, [] 연산이 가능한 반복자(vector, deque)

//5.스마트포인터… ? / ->객체를 가르키고 있다가 객체가 사라지면 자동으로 풀림
//	?왜쓰냐 ? 자원을 쓰기위해서… 알아서 풀어주니깐 누수 날일 없자나!


============================================================================================================
                            저장시간 : 2021-03-09 오후 4:03:27 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (2주 1일)
// 이번시간 - 자료구조 +(iterator) 알고리즘 -> STL
//			- 많은 수의 데이터
//			- 
//			- 많은 수의 정수(<- 애 말고 클래스로 바꿔서...ㅎㅎ) 데이터 다루기 - 정렬
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <random>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐


// [문제] 임의의 값(랜덤엔진과 분포)을 갖는 정수
// 를 몆개까지 만들 수 있나? --> 램이 꽉찰때까지....
// 내림차순으로 정렬해 봐라.
// 제일 처음과 마지막 원소만 출력해봐라...
default_random_engine dre;


int a[10]; // 40MB <- int는 4...



class ABC {
public:
	bool operator()(int a, int b) {
		return a > b;
	};
};

int main()
{
	uniform_int_distribution<> uid;

	for (int& num : a)
		num = uid(dre);

	cout << "정렬 시작!" << endl;
	int count = 0;
	ABC x;
//	sort(begin(a), end(a)); // 마지막 3번쨰 인자는 숨겨져있음 알려주면 됨 :) 그럼 내림차순도 된데이~ / 함수로 만들어준다 :)
	sort(begin(a), end(a), [](int a, int b) {return a > b; });

	// 1. 일반함수를 넣을수 있다. (return a > b 해주는 compare 같은 함수)
	// 2. 람다함수를 넣을수 있다. 해봤자나! [](){} <- 이름엄슴 ㅎ 이거쓰면 어떻게 흘러가는지 알수 있어서 아주 좋다고 하심.
	// 3. 호출가능 타입은 넣을수 있다고 합니다.
	// sort 3번쨰 인자는 호출가능 타입이면 넣을 수 있다!!!!!!!!!!!

	// 람다는 그냥 함수보다 빠르다? -> 이건 찾아봐야할듯...  굳이 다른데 호출하러 가지 않아도 되니깐 빠르당 :) (template 이다) (함수의 인라인화) !!!

	// * -> d reference operator

	cout << "첫 원소 : "<< *begin(a) << endl;
	cout << "마지막 원소 : " << *(end(a) - 1) << endl;

	cout << "비교 호출 횟수 - " << count << endl;
	save("2021STL.cpp");
}










//오늘자 질문 들어올거 예상중….
//
//1.레퍼런스가 뭐야 ?
//?	원격제어를 하기위한 친구
//?(포인터를 이용하지만 포인터처럼 주소값을 바꾼다 같은 짓은 못함) 참조!!!!
//

//2.지역변수와 전역변수의 차이점 :
//

//3.정수 만개를 저장하려면 최소 몆바이트가 필요할까 ?
//?	최소 4만 바이트(근데 아마 4만보단 클거임….이유는 바이너리모드와 텍스트모드의 차이(바이너리모드와 텍스트모드로 파일을 열수 있어….)

//4.반복자 ?
//	-입력 반복자(input iterator) : 현 위치의 원소를 한 번만 읽을 수 있반복자(istream)
//	- 출력 반복자(output iterator) : 현 위치의 원소를 한 번만 쓸 수 있는 반복자(ostream)
//	- 순방향 반복자(forward iterator) : 입력, 출력 반복자 기능에 순방향으로 이동(++)이 가능한 재할당될 수 있는 반복자
//	- 양방향 반복자(bidirectional iterator) : 순방향 반복자 기능에 역방향으로 이동(--)이 가능한 반복자
//	(list, set, mulitset, map, multimap)
//	- 임의 접근 반복자(random access iterator) : 양방향 반복자 기능에 + , -, +=, -=, [] 연산이 가능한 반복자(vector, deque)

//5.스마트포인터… ? / ->객체를 가르키고 있다가 객체가 사라지면 자동으로 풀림
//	?왜쓰냐 ? 자원을 쓰기위해서… 알아서 풀어주니깐 누수 날일 없자나!


============================================================================================================
                            저장시간 : 2021-03-09 오후 4:32:13 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (2주 1일)
// 이번시간 - 자료구조 +(iterator) 알고리즘 -> STL
//			- 많은 수의 데이터
//			- 
//			- 많은 수의 정수(<- 애 말고 클래스로 바꿔서...ㅎㅎ) 데이터 다루기 - 정렬
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐


// [문제] int 10개를 저장할 공간을 확보한다.
// 1~10까지 순서대로 채운다.
// int 10개를 파일에 기록한다. "int10개.txt" 에다가!

// 기록을 확인하였다면 프로그램을 다시 작성하여 
// 파일 "int10개.txt" 읽어 화면에 출력하라.

int main()
{
	int num[10]{ 1,2,3,4,5,6,7,8,9,10 };

	ofstream out("int10개.txt"sv); // 접미사를 붙히는 이유.... -> string 객체라고 알려주는거임
	
	for (int& d : num)
		out << d;

	save("2021STL.cpp");
}












============================================================================================================
                            저장시간 : 2021-03-09 오후 4:33:48 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (2주 1일)
// 이번시간 - 자료구조 +(iterator) 알고리즘 -> STL
//			- 많은 수의 데이터
//			- 
//			- 많은 수의 정수(<- 애 말고 클래스로 바꿔서...ㅎㅎ) 데이터 다루기 - 정렬
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐


// [문제] int 10개를 저장할 공간을 확보한다.
// 1~10까지 순서대로 채운다.
// int 10개를 파일에 기록한다. "int10개.txt" 에다가!

// 기록을 확인하였다면 프로그램을 다시 작성하여 
// 파일 "int10개.txt" 읽어 화면에 출력하라.

int main()
{
	int num[10]{ 1,2,3,4,5,6,7,8,9,10 };

	ofstream out("int10개.txt"sv); // 접미사를 붙히는 이유.... -> string 객체라고 알려주는거임
	
	for (int& d : num)
		out << d << endl;
	save("2021STL.cpp");
}












============================================================================================================
                            저장시간 : 2021-03-09 오후 4:43:40 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (2주 1일)
// 이번시간 - 자료구조 +(iterator) 알고리즘 -> STL
//			- 많은 수의 데이터
//			- 
//			- 많은 수의 정수(<- 애 말고 클래스로 바꿔서...ㅎㅎ) 데이터 다루기 - 정렬
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐


// [문제] int 10개를 저장할 공간을 확보한다.
// 1~10까지 순서대로 채운다.
// int 10개를 파일에 기록한다. "int10개.txt" 에다가!

// 기록을 확인하였다면 프로그램을 다시 작성하여 
// 파일 "int10개.txt" 읽어 화면에 출력하라.

int main()
{
	int readNum[10]{ 0 };
	int i = 0;

	ifstream in("int10개.txt"sv);
	
	if (!in) {
		cout << "파일 열수 없다." << endl;
		exit(0);
	}
	
	for (int i = 0; i < 10; ++i) {
		in >> readNum[i];
		cout << readNum[i] << " ";
	}
	cout << endl;

	save("2021STL.cpp");
}












============================================================================================================
                            저장시간 : 2021-03-09 오후 4:52:12 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (2주 1일)
// 이번시간 - 자료구조 +(iterator) 알고리즘 -> STL
//			- 많은 수의 데이터
//			- 
//			- 많은 수의 정수(<- 애 말고 클래스로 바꿔서...ㅎㅎ) 데이터 다루기 - 정렬
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐


// [문제] int 10000개를 1부터 10000까지 값으로 채워라.
// 파일에 "int만개.txt"로 기록한다.
// (질문) ? : 하드디스크에 파일 크기를 확인하고 결과를 설명하라.

int a[10'000]{1}; // <- 초기화를 하냐 안하냐 차이가 존내 크다!

int main()
{
	iota(begin(a), end(a), 1);

	ofstream out("int만개.txt");
	
	for (int& d : a)
		out << d << " ";


	save("2021STL.cpp");
}












============================================================================================================
                            저장시간 : 2021-03-09 오후 4:56:13 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (2주 1일)
// 이번시간 - 자료구조 +(iterator) 알고리즘 -> STL
//			- 많은 수의 데이터
//			- 
//			- 많은 수의 정수(<- 애 말고 클래스로 바꿔서...ㅎㅎ) 데이터 다루기 - 정렬
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐


// [문제] int 10000개를 1부터 10000까지 값으로 채워라.
// 파일에 "int만개.txt"로 기록한다.
// (질문) ? : 하드디스크에 파일 크기를 확인하고 결과를 설명하라.

int a[10'000]{1}; // <- 초기화를 하냐 안하냐 차이가 존내 크다!

int main()
{
	iota(begin(a), end(a), 1);

	ofstream out("int만개.txt", ios::binary);
	
	for (int& d : a)
		out << d << " ";


	save("2021STL.cpp");
}












============================================================================================================
                            저장시간 : 2021-03-09 오후 4:58:01 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (2주 1일)
// 이번시간 - 자료구조 +(iterator) 알고리즘 -> STL
//			- 많은 수의 데이터
//			- 
//			- 많은 수의 정수(<- 애 말고 클래스로 바꿔서...ㅎㅎ) 데이터 다루기 - 정렬
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐


// [문제] int 10000개를 1부터 10000까지 값으로 채워라.
// 파일에 "int만개.txt"로 기록한다.
// (질문) ? : 하드디스크에 파일 크기를 확인하고 결과를 설명하라.

int a[10'000]{1}; // <- 초기화를 하냐 안하냐 차이가 존내 크다!

int main()
{
	iota(begin(a), end(a), 1);

	ofstream out("int만개.txt", ios::binary);
	out.write((char*)a, sizeof(int) * 10000);


	save("2021STL.cpp");
}












============================================================================================================
                            저장시간 : 2021-03-09 오후 5:08:47 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (2주 1일)
// 이번시간 - 자료구조 +(iterator) 알고리즘 -> STL
//			- 많은 수의 데이터
//			- 
//			- 많은 수의 정수(<- 애 말고 클래스로 바꿔서...ㅎㅎ) 데이터 다루기 - 정렬
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐


// [문제] int 10000개를 1부터 10000까지 값으로 채워라.
// 파일에 "int만개.txt"로 기록한다.
// (질문) ? : 하드디스크에 파일 크기를 확인하고 결과를 설명하라.
// (이유) ? : 텍스트모드와 바이너리모드 차이!

// [과제] 하드디스크의 용량을 10'000 * sizeof(int) 만큼 소비해야 한다.

int a[10'000]{1}; // <- 초기화를 하냐 안하냐 차이가 존내 크다!

int main()
{
	iota(begin(a), end(a), 1);

	// low level로 코딩한다.
	// 기본은 텍스트모드로 저장을 하기 때문에 
	ofstream out("int만개.txt", ios::binary);
	out.write((char*)a, sizeof(a));


	save("2021STL.cpp");
}












============================================================================================================
                            저장시간 : 2021-03-09 오후 5:09:12 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (2주 1일)
// 이번시간 - 자료구조 +(iterator) 알고리즘 -> STL
//			- 많은 수의 데이터
//			- 
//			- 많은 수의 정수(<- 애 말고 클래스로 바꿔서...ㅎㅎ) 데이터 다루기 - 정렬
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐


// [문제] int 10000개를 1부터 10000까지 값으로 채워라.
// 파일에 "int만개.txt"로 기록한다.
// (질문) ? : 하드디스크에 파일 크기를 확인하고 결과를 설명하라.
// (이유) ? : 텍스트모드와 바이너리모드 차이!

// [과제] 하드디스크의 용량을 10'000 * sizeof(int) 만큼 소비해야 한다.

int a[10'000]{1}; // <- 초기화를 하냐 안하냐 차이가 존내 크다!

int main()
{
	iota(begin(a), end(a), 1);

	// low level로 코딩한다.
	// 기본은 텍스트모드로 저장을 하기 때문에 
	ofstream out("int만개.txt", ios::binary);
	out.write((char*)a, sizeof(a));


	save("2021STL.cpp");
}












============================================================================================================
                            저장시간 : 2021-03-09 오후 5:10:07 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 2일 목요일 (2주 1일)
// 이번시간 - 자료구조 +(iterator) 알고리즘 -> STL
//			- 많은 수의 데이터
//			- 
//			- 많은 수의 정수(<- 애 말고 클래스로 바꿔서...ㅎㅎ) 데이터 다루기 - 정렬
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐


// [문제] int 10000개를 1부터 10000까지 값으로 채워라.
// 파일에 "int만개.txt"로 기록한다.
// (질문) ? : 하드디스크에 파일 크기를 확인하고 결과를 설명하라.
// (이유) ? : 텍스트모드와 바이너리모드 차이!

// [과제] 하드디스크의 용량을 10'000 * sizeof(int) 만큼 소비해야 한다.

int a[10'000]{1}; // <- 초기화를 하냐 안하냐 차이가 존내 크다!

int main()
{
	iota(begin(a), end(a), 1234567890);

	// low level로 코딩한다.
	// 기본은 텍스트모드로 저장을 하기 때문에 
	ofstream out("int만개.txt", ios::binary);
	out.write((char*)a, sizeof(int) * 10000);


	save("2021STL.cpp");
}












============================================================================================================
                            저장시간 : 2021-03-11 오전 10:52:49 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 이번시간 - 스마트 포인터
//			- 사용자 정의 자료형을 읽고 쓰기
//			- 알고리즘 시간 측정!
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐

// [문제] 사용자가 원하는 갯수 만큼 int를 저장할 공간을 마련한다.
// 그 공간을 1부터 n까지 값으로 채워라.
// 제일 처음 값과 마지막값을 화면에 출력하라.


// [ ] <- 연속된!!!! contiguous (메모리가 연속됨) / 공간의 연속성 g 시간의 연속성

int main()
{
	int select;

	cout << "원하는 갯수: ";
	cin >> select;
	
	int* p = new int[select];


	iota(p, p + select , 1);


	cout << "처음값: " << *p << endl;
	cout << "끝값: " << *(p + select - 1) << endl;

	delete[] p;

	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오전 11:01:16 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 이번시간 - 스마트 포인터
//			- 사용자 정의 자료형을 읽고 쓰기
//			- 알고리즘 시간 측정!
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐

// [문제] 사용자가 원하는 갯수 만큼 int를 저장할 공간을 마련한다.
// 그 공간을 1부터 n까지 값으로 채워라.
// 제일 처음 값과 마지막값을 화면에 출력하라.


// [ ] <- 연속된!!!! contiguous (메모리가 연속됨) / 공간의 연속성 g 시간의 연속성

int main()
{
	int select;
	save("2021STL.cpp");
	while (1) {
		cout << "원하는 갯수: ";
		cin >> select;

		int* p = new int[select];


		//iota(p, p + select , 1);

		for (int i = 0; i < select; ++i)
			p[i] = i + 1;


		cout << "처음값: " << *p << endl;
		cout << "끝값: " << *(p + select - 1) << endl;

		delete[] p;
	}
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오전 11:09:25 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 이번시간 - 스마트 포인터
//			- 사용자 정의 자료형을 읽고 쓰기
//			- 알고리즘 시간 측정!
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐

// [문제] 사용자가 원하는 갯수 만큼 int를 저장할 공간을 마련한다.
// 그 공간을 1부터 n까지 값으로 채워라.
// 제일 처음 값과 마지막값을 화면에 출력하라.


// [ ] <- 연속된!!!! contiguous (메모리가 연속됨) / 공간의 연속성 g 시간의 연속성

int main()
{
	int select;
	save("2021STL.cpp");
	while (1) {
		cout << "원하는 갯수: ";
		cin >> select;

		// 메모리를 줄 수 없으면 예외를 던진다!
		int* p;
		try{
			p = new int[select];
		}
		// 그 예외를 잡는다!
		catch (exception& e) {
			cout << e.what() << endl;
		}

		//iota(p, p + select , 1);

		for (int i = 0; i < select; ++i)
			p[i] = i + 1;


		cout << "처음값: " << *p << endl;
		cout << "끝값: " << *(p + select - 1) << endl;

		delete[] p;
	}
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오전 11:18:20 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 이번시간 - 스마트 포인터
//			- 사용자 정의 자료형을 읽고 쓰기
//			- 알고리즘 시간 측정!
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <memory>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐

// [문제] 사용자가 원하는 갯수 만큼 int를 저장할 공간을 마련한다.
// 그 공간을 1부터 n까지 값으로 채워라.
// 제일 처음 값과 마지막값을 화면에 출력하라.


// [ ] <- 연속된!!!! contiguous (메모리가 연속됨) / 공간의 연속성 g 시간의 연속성

int main()
{
	int select;
	save("2021STL.cpp");
	while (1) {
		cout << "원하는 갯수: ";
		cin >> select;

//		int* p = new int[select]; // <- 원시포인터... 너무 옛것 ㅋ
		unique_ptr<int> p(new int[select]);

		//iota(p, p + select , 1);


		cout << "끝값: " << p.get() << endl;
	}
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오전 11:20:21 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 이번시간 - 스마트 포인터
//			- 사용자 정의 자료형을 읽고 쓰기
//			- 알고리즘 시간 측정!
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <memory>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐

// [문제] 사용자가 원하는 갯수 만큼 int를 저장할 공간을 마련한다.
// 그 공간을 1부터 n까지 값으로 채워라.
// 제일 처음 값과 마지막값을 화면에 출력하라.


// [ ] <- 연속된!!!! contiguous (메모리가 연속됨) / 공간의 연속성 g 시간의 연속성

int main()
{
	int select;
	save("2021STL.cpp");
	while (1) {
		cout << "원하는 갯수: ";
		cin >> select;

//		int* p = new int[select]; // <- 원시포인터... 너무 옛것 ㅋ
		unique_ptr<int[]> p(new int[select]);

		for(int i = 0; i < select; ++i)
			p[i] = i + 1;
		//iota(p, p + select , 1);


		cout << "끝값: " << p[select - 1] << endl;
	}
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오전 11:21:05 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 이번시간 - 스마트 포인터
//			- 사용자 정의 자료형을 읽고 쓰기
//			- 알고리즘 시간 측정!
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <memory>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐

// [문제] 사용자가 원하는 갯수 만큼 int를 저장할 공간을 마련한다.
// 그 공간을 1부터 n까지 값으로 채워라.
// 제일 처음 값과 마지막값을 화면에 출력하라.


// [ ] <- 연속된!!!! contiguous (메모리가 연속됨) / 공간의 연속성 g 시간의 연속성

int main()
{
	int select;
	save("2021STL.cpp");
	while (1) {
		cout << "원하는 갯수: ";
		cin >> select;

//		int* p = new int[select]; // <- 원시포인터... 너무 옛것 ㅋ
		unique_ptr<int[]> p(new int[select]); // <= 날것 그대로 위에거 쓰지말고 이거써라.... 이거 쓰라잖냐!!!!

		for(int i = 0; i < select; ++i)
			p[i] = i + 1;
		//iota(p, p + select , 1);


		cout << "끝값: " << p[select - 1] << endl;
	}
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오전 11:35:27 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 이번시간 - 스마트 포인터
//			- 사용자 정의 자료형을 읽고 쓰기
//			- 알고리즘 시간 측정!
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <memory>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐

// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

int main()
{
	save("2021STL.cpp");
	int cnt = 0;

	while (1) {
		new char[400'000'000];
		cout << "메모리 할당 성공 : " <<++cnt << endl;
	}
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오전 11:35:44 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 이번시간 - 스마트 포인터
//			- 사용자 정의 자료형을 읽고 쓰기
//			- 알고리즘 시간 측정!
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <memory>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐

// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

int main()
{
	save("2021STL.cpp");
	int cnt = 0;

	while (1) {
		new char[400'000'000];
		cout << "메모리 할당 성공 : " <<++cnt << endl;
	}
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오전 11:36:04 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 이번시간 - 스마트 포인터
//			- 사용자 정의 자료형을 읽고 쓰기
//			- 알고리즘 시간 측정!
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <memory>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐

// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

int main()
{
	save("2021STL.cpp");
	int cnt = 0;

	while (1) {
		new char[200'000'000];
		cout << "메모리 할당 성공 : " <<++cnt << endl;
	}
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오전 11:36:58 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 이번시간 - 스마트 포인터
//			- 사용자 정의 자료형을 읽고 쓰기
//			- 알고리즘 시간 측정!
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <memory>
#include <thread>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐

// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

int main()
{
	save("2021STL.cpp");
	int cnt = 0;

	while (1) {
		new char[200'000'000];
		cout << "메모리 할당 성공 : " <<++cnt << endl;
		
		this_thread::sleep_for(10s);
	}
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오전 11:38:21 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 이번시간 - 스마트 포인터
//			- 사용자 정의 자료형을 읽고 쓰기
//			- 알고리즘 시간 측정!
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <memory>
#include <thread>
#include <fstream>
#include <ostream>
#include "save.h"

using namespace std; // <- ? 왜 혼자 뻘거냐

// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

int main()
{
	save("2021STL.cpp");
	int cnt = 0;

	while (1) {
		new char[200'000'000];
		cout << "메모리 할당 성공 : " <<++cnt << endl;
		
		this_thread::sleep_for(3s);
	}
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오후 12:02:09 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 
// 알고리즘 시간 재기
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <chrono>
#include <thread>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

int main()
{
	
	// 시간재기 시작
	chrono::steady_clock::time_point begin = chrono::steady_clock::now();

	this_thread::sleep_for(1ns);
	
	// 시간재기 끝
	chrono::steady_clock::now();
	
	
	cout << "경과 시간 - " << endl;
	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오후 12:04:01 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 
// 알고리즘 시간 재기
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <chrono>
#include <thread>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

int main()
{
	
	// 시간재기 시작
	auto begin = chrono::steady_clock::now();

	this_thread::sleep_for(1ns);
	
	// 시간재기 끝
	auto end = chrono::steady_clock::now();
	
	auto d = end - begin;
	
	cout << "경과 시간 - " << d.count() << endl;
	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오후 12:04:15 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 
// 알고리즘 시간 재기
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <chrono>
#include <thread>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

int main()
{
	
	// 시간재기 시작
	auto begin = chrono::steady_clock::now();

	this_thread::sleep_for(1s);
	
	// 시간재기 끝
	auto end = chrono::steady_clock::now();
	
	auto d = end - begin;
	
	cout << "경과 시간 - " << d.count() << endl;
	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오후 12:06:05 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 
// 알고리즘 시간 재기
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <chrono>
#include <thread>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

int main()
{
	
	// 시간재기 시작
	auto begin = chrono::steady_clock::now();

	this_thread::sleep_for(1s);
	
	// 시간재기 끝
	auto end = chrono::steady_clock::now();
	
	auto d = end - begin;
	
	cout << "경과 시간(밀리초) - " << chrono::duration_cast<chrono::microseconds>(d).count() << endl;
	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오후 12:06:42 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 
// 알고리즘 시간 재기
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <chrono>
#include <thread>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

int main()
{
	
	// 시간재기 시작
	auto begin = chrono::steady_clock::now();

	this_thread::sleep_for(1s);
	
	// 시간재기 끝
	auto end = chrono::steady_clock::now();
	
	auto d = end - begin;
	
	cout << "경과 시간(밀리초) - " << chrono::duration_cast<chrono::milliseconds>(d).count() << endl;
	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오후 12:07:13 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 
// 알고리즘 시간 재기
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <chrono>
#include <thread>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

int main()
{
	
	// 시간재기 시작
	auto begin = chrono::steady_clock::now();

	this_thread::sleep_for(123ms);
	
	// 시간재기 끝
	auto end = chrono::steady_clock::now();
	
	auto d = end - begin;
	
	cout << "경과 시간(밀리초) - " << chrono::duration_cast<chrono::milliseconds>(d).count() << endl;
	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오후 12:12:15 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 
// 알고리즘 시간 재기
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <chrono>
#include <thread>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

int main()
{
	using namespace std::chrono;

	// 시간재기 시작
	auto begin = steady_clock::now();

	this_thread::sleep_for(123ms);

	// 시간재기 끝
	cout << "경과 시간(밀리초) - " << duration_cast<chrono::milliseconds>(steady_clock::now() - begin).count() << endl;
	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오후 12:13:02 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 
// 알고리즘 시간 재기
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <chrono>
#include <thread>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

int main()
{
	using namespace std::chrono;

	// 시간재기 시작
	auto begin = steady_clock::now();

	this_thread::sleep_for(123ms);

	// 시간재기 끝
	cout << "경과 시간(밀리초) - " << duration_cast<seconds>(steady_clock::now() - begin).count() << endl;
	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오후 12:13:20 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 
// 알고리즘 시간 재기
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <chrono>
#include <thread>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

int main()
{
	using namespace std::chrono;

	// 시간재기 시작
	auto begin = steady_clock::now();

	this_thread::sleep_for(123ms);

	// 시간재기 끝
	cout << "경과 시간(밀리초) - " << duration_cast<milliseconds>(steady_clock::now() - begin).count() << endl;
	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-11 오후 12:16:01 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (2주 2일)
// 
// 알고리즘 시간 재기
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.

class Dog {
private:
	string name;
	int age;

public:
};

int main()
{
	cout << "Dog의 크기 : " << sizeof(Dog) << endl;
	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-16 오후 3:47:20 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// 
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.
default_random_engine dre;
uniform_int_distribution<> uid{ 1,10'0000 };

class Dog {
private:
	string name;
	int id;
	static int cnt;

public:
	Dog() : id{ uid(dre) }, name{ "Dog"s } {
		id = uid(dre);
		name += cnt;
		++cnt;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt{ 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ", " << dog.id << endl;
	return os;
}
// [문제] Dog 10'000 객체를 생성한다.
// - name은 Dog + 1부터 시작되는 숫자로.
// - ID는 [1,100'000]까지 랜덤으로!

// - 파일에 메모리 크기 그대로 기록한다.
// - (확인) 크기 == sizeof(Dog) * 10'000 이어야 한다.

// - 파일에서 읽어와라!
// - ID 오름차순으로 정렬하라!
// - 전부 다 출력 해봐라!

int main()
{
	Dog dogs[10];

	for (Dog dog : dogs)
		cout << dog << endl;

	
	cout << "Dog의 크기 : " << sizeof(Dog) << endl;
	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-16 오후 3:50:15 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// 
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.
default_random_engine dre;
uniform_int_distribution<> uid{ 1,10'0000 };

class Dog {
private:
	string name;
	int id;
	static int cnt;

public:
	Dog() : id{ uid(dre) }, name{ "Dog"s } {
		id = uid(dre);
		name += to_string(cnt);
		++cnt;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt{ 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ", " << dog.id << endl;
	return os;
}
// [문제] Dog 10'000 객체를 생성한다.
// - name은 Dog + 1부터 시작되는 숫자로.
// - ID는 [1,100'000]까지 랜덤으로!

// - 파일에 메모리 크기 그대로 기록한다.
// - (확인) 크기 == sizeof(Dog) * 10'000 이어야 한다.

// - 파일에서 읽어와라!
// - ID 오름차순으로 정렬하라!
// - 전부 다 출력 해봐라!

int main()
{
	Dog dogs[10];

	for (Dog dog : dogs)
		cout << dog << endl;

	
	cout << "Dog의 크기 : " << sizeof(Dog) << endl;
	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-16 오후 3:50:48 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// 
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.
default_random_engine dre;
uniform_int_distribution<> uid{ 1,10'0000 };

class Dog {
private:
	string name;
	int id;
	static int cnt;

public:
	Dog() : id{ uid(dre) }, name{ "Dog"s } {
		id = uid(dre);
		name += to_string(cnt);
		++cnt;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt{ 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ", " << dog.id << endl;
	return os;
}
// [문제] Dog 10'000 객체를 생성한다.
// - name은 Dog + 1부터 시작되는 숫자로.
// - ID는 [1,100'000]까지 랜덤으로!

// - 파일에 메모리 크기 그대로 기록한다.
// - (확인) 크기 == sizeof(Dog) * 10'000 이어야 한다.

// - 파일에서 읽어와라!
// - ID 오름차순으로 정렬하라!
// - 전부 다 출력 해봐라!

int main()
{
	Dog dogs[10'000];

	for (Dog dog : dogs)
		cout << dog << endl;

	
	cout << "Dog의 크기 : " << sizeof(Dog) << endl;
	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-16 오후 4:03:20 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// 
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.
default_random_engine dre;
uniform_int_distribution<> uid{ 1,10'0000 };

class Dog {
private:
	string name;
	int id;
	static int cnt;

public:
	Dog() : id{ uid(dre) }, name{ "Dog"s } {
		id = uid(dre);
		name += to_string(cnt);
		++cnt;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt{ 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ", " << dog.id << endl;
	return os;
}


// - 파일에서 읽어와라!
// - ID 오름차순으로 정렬하라!
// - 전부 다 출력 해봐라!

int main()
{
	Dog dogs[10'000];

	//for (Dog dog : dogs)
	//	cout << dog << endl;


	//Dog 10'000개는 28*10'000

	cout << "파일크기 확인 - " << sizeof(Dog) * 10'000 << " 바이트" << endl;

	ofstream out("Dog1만마리.txt"s, ios::binary);
	out.write((char*)dogs, sizeof(Dog) * 10'000);
	
	for (Dog dog : dogs)
		out << dog;
	

	//const chat* 을 받는다
	cout << "Dog의 크기 : " << sizeof(Dog) << endl;
	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-16 오후 4:12:09 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// 
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.
default_random_engine dre;
uniform_int_distribution<> uid{ 1,10'0000 };

class Dog {
private:
	string name;
	int id;
	static int cnt;

public:
	Dog() : id{ uid(dre) }, name{ "Dog"s } {
		id = uid(dre);
		name += to_string(cnt);
		++cnt;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt{ 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ", " << dog.id << endl;
	return os;
}


// [문제] "Dog 만객체" 에는 Dog 10'000 객체가 바이너리 모드로 저장되어 있다.
// 읽어서 id 오름차순으로 정렬한 후 출력하라.
//

int main()
{
	Dog dogs[10'000];

	ifstream in("Dog1만마리.txt"s, ios::binary);
	if (!in)
		exit(0);

	for (Dog dog : dogs) {
		in.read((char*)dogs, sizeof(Dog));
		cout << dog;
	}

	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-16 오후 4:16:36 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// 
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.
default_random_engine dre;
uniform_int_distribution<> uid{ 1,10'0000 };

class Dog {
private:
	string name;
	int id;
	static int cnt;

public:
	Dog() : id{ uid(dre) }, name{ "Dog"s } {
		id = uid(dre);
		name += to_string(cnt);
		++cnt;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt{ 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ", " << dog.id << endl;
	return os;
}


// [문제] "Dog 만객체" 에는 Dog 10'000 객체가 바이너리 모드로 저장되어 있다.
// 읽어서 id 오름차순으로 정렬한 후 출력하라.
//

Dog dogs[10'000];
int as[10'000'000]{ 12,33,55,5343 };
int main()
{
	ifstream in("Dog1만마리.txt"s, ios::binary);
	if (!in)
		exit(0);

	for (Dog dog : dogs) {
		in.read((char*)dogs, sizeof(Dog));
		cout << dog;
	}

	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-16 오후 4:19:00 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// 
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.
default_random_engine dre;
uniform_int_distribution<> uid{ 1,10'0000 };

class Dog {
private:
	string name;
	int id;
	static int cnt;

public:
	Dog() : id{ uid(dre) }, name{ "Dog"s } {
		id = uid(dre);
		name += to_string(cnt);
		++cnt;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt{ 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ", " << dog.id << endl;
	return os;
}


// [문제] "Dog 만객체" 에는 Dog 10'000 객체가 바이너리 모드로 저장되어 있다.
// 읽어서 id 오름차순으로 정렬한 후 출력하라.
//

Dog dogs[10'000]{};

int main()
{
	ifstream in("Dog1만마리.txt"s, ios::binary);
	if (!in)
		exit(0);
	
	new Dog[10'000];
	in.read((char*)dogs, sizeof(Dog) * 10'000);

	for (Dog dog : dogs)
		cout << dog;

	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-16 오후 4:35:51 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// 
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.
default_random_engine dre;
uniform_int_distribution<> uid{ 1,10'0000 };

class Dog {
private:
	string name;
	int id;
	static int cnt;

public:
	Dog() : id{ uid(dre) }, name{ "Dog"s } {
		id = uid(dre);
		name += to_string(cnt);
		++cnt;
	}

	Dog(const Dog&) {
		cout << "복사하지마" << endl;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
	friend ostream& operator<(ostream& os, const Dog& dog);
};

int Dog::cnt{ 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ", " << dog.id << endl;
	return os;
}


// [문제] "Dog 만객체" 에는 Dog 10'000 객체가 바이너리 모드로 저장되어 있다.
// 읽어서 id 오름차순으로 정렬한 후 출력하라.
//

Dog dogs[10'000]{};

int main()
{
	ifstream in("Dog1만마리.txt"s, ios::binary);
	if (!in)
		exit(0);

	in.read((char*)dogs, sizeof(Dog) * 10'000);

	for (const Dog& dog : dogs)
		cout << dog;

	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-16 오후 4:42:37 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// 
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.
default_random_engine dre;
uniform_int_distribution<> uid{ 1,10'0000 };

class Dog {
private:
	string name;
	int id;
	static int cnt;

public:
	Dog() : id{ uid(dre) }, name{ "Dog"s } {
		id = uid(dre);
		name += to_string(cnt);
		++cnt;
	}

	int get_id() const{
		return id;
	}
	friend ostream& operator<<(ostream& os, const Dog& dog);
	friend ostream& operator<(ostream& os, const Dog& dog);
};

int Dog::cnt{ 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ", " << dog.id << endl;
	return os;
}


// [문제] "Dog 만객체" 에는 Dog 10'000 객체가 바이너리 모드로 저장되어 있다.
// 읽어서 id 오름차순으로 정렬한 후 출력하라.
//

Dog dogs[10'000]{};

int main()
{
	ifstream in("Dog1만마리.txt"s, ios::binary);
	if (!in)
		exit(0);

	in.read((char*)dogs, sizeof(Dog) * 10'000);

	sort(begin(dogs), end(dogs), [](const Dog& a, const Dog& b) {
			return a.get_id() < b.get_id();
		});
	
	for (const Dog& dog : dogs)
		cout << dog;


	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-16 오후 4:49:11 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// 
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.
default_random_engine dre;
uniform_int_distribution<> uid{ 1,10'0000 };

class Dog {
private:
	string name;
	int id;
	static int cnt;

public:
	Dog() : id{ uid(dre) }, name{ "Dog"s } {
		id = uid(dre);
		name += to_string(cnt);
		++cnt;
	}

	int get_id() const{
		return id;
	}

	string_view get_name() const {
		return name;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
	friend ostream& operator<(ostream& os, const Dog& dog);
};

int Dog::cnt{ 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ", " << dog.id << endl;
	return os;
}


// [문제] "Dog 만객체" 에는 Dog 10'000 객체가 바이너리 모드로 저장되어 있다.
// 읽어서 id 오름차순으로 정렬한 후 출력하라.
//

Dog dogs[10'000]{};

int main()
{
	ifstream in("Dog1만마리.txt"s, ios::binary);
	if (!in)
		exit(0);

	in.read((char*)dogs, sizeof(Dog) * 10'000);

	sort(begin(dogs), end(dogs), [](const Dog& a, const Dog& b) {
			return a.get_id() < b.get_id();
		});
	
	sort(begin(dogs), end(dogs), [](const Dog& a, const Dog& b) {
		return a.get_name() < b.get_name();
		});

	for (const Dog& dog : dogs)
		cout << dog;


	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-16 오후 4:53:00 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// 
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.
default_random_engine dre;
uniform_int_distribution<> uid{ 1,10'0000 };

class Dog {
private:
	string name;
	int id;
	static int cnt;

public:
	Dog() : id{ uid(dre) }, name{ "Dog"s } {
		id = uid(dre);
		name += to_string(cnt);
		++cnt;
	}

	int get_id() const{
		return id;
	}

	string_view get_name() const {
		return name;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
	friend ostream& operator<(ostream& os, const Dog& dog);
};

int Dog::cnt{ 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ", " << dog.id << endl;
	return os;
}


// [문제] "Dog 만객체" 에는 Dog 10'000 객체가 바이너리 모드로 저장되어 있다.
// 동적으로 할당한 메모리에 읽은 다음 정렬하여 출력하라!
//

int main()
{

	Dog *dogs = new Dog[10'000];
	
	ifstream in("Dog1만마리.txt"s, ios::binary);
	if (!in)
		exit(0);

	in.read((char*)dogs, sizeof(Dog) * 10'000);

	sort(dogs, dogs + 10000, [](const Dog& a, const Dog& b) {
		return a.get_id() < b.get_id();
		});

	for (int i = 0; i < 10'000; ++i)
		cout << dogs[i];


	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-16 오후 5:01:25 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// 
//
// 다음시간 실습해 봅니다 - class Dog 읽고 쓰기
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;
// [문제] 메모리를 계속 요청해 본다.
// 작업관리자를 켜서 메모리 사용량을 관찰한다.
default_random_engine dre;
uniform_int_distribution<> uid{ 1,10'0000 };

class Dog {
private:
	string name;
	int id;
	static int cnt;

public:
	Dog() : id{ uid(dre) }, name{ "Dog"s } {
		id = uid(dre);
		name += to_string(cnt);
		++cnt;
	}
	~Dog() {
		//cout << name << "이 주겄당!" << endl;
	}

	int get_id() const{
		return id;
	}

	string_view get_name() const {
		return name;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog);
	friend ostream& operator<(ostream& os, const Dog& dog);
};

int Dog::cnt{ 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.name << ", " << dog.id << endl;
	return os;
}


// [문제] "Dog 만객체" 에는 Dog 10'000 객체가 바이너리 모드로 저장되어 있다.
// 동적으로 할당한 메모리에 읽은 다음 정렬하여 출력하라!
//

int main()
{
	unique_ptr<Dog[]> dogs{ new Dog[10'000] }; // 포인터 크기 4바이트!
	
	ifstream in("Dog1만마리.txt"s, ios::binary);
	if (!in)
		exit(0);

	in.read((char*)dogs.get(), sizeof(Dog) * 10'000);

	sort(&dogs[0], dogs.get() + 10'000 , [](const Dog& a, const Dog& b) {
		return a.get_id() < b.get_id();
		});

	for (int i = 0; i < 10'000; ++i)
		cout << dogs[i];

	save("2021STL.cpp");
}

// 반복자? 자료를 순회 혹은 참조할떄 ㅎㅎ










============================================================================================================
                            저장시간 : 2021-03-16 오후 5:08:15 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// callable type - 호출 가능 타입
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;

void x()
{
	cout << "나는 그냥함수 x야!" << endl;
}

int main()
{
	x(); // 함수 호출 연산자 ()! 1. 함수 2. 

	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-16 오후 5:08:58 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// callable type - 호출 가능 타입
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;

void x()
{
	cout << "나는 그냥함수 x야!" << endl;
}

int main()
{
	x(); // 함수 호출 연산자 ()! 1. 함수 2. 

	cout << typeid(x).name() << endl;
	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-16 오후 5:10:46 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// callable type - 호출 가능 타입
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;

void x()
{
	cout << "나는 그냥함수 x야!" << endl;
}

int main()
{
	//x(); // 함수 호출 연산자 ()! 1. 함수 2. 

	auto f = x;
	f;

	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-16 오후 5:13:35 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// callable type - 호출 가능 타입
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;

void x()
{
	cout << "나는 그냥함수 x야!" << endl;
}

int main()
{
	//x(); // 함수 호출 연산자 ()! 1. 함수 2. 
	x();

	void (*y)(void) = x;
	y();

	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-16 오후 5:15:01 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// callable type - 호출 가능 타입
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;

void x()
{
	cout << "나는 그냥함수 x야!" << endl;
}

int main()
{
	(*x)();

	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-16 오후 5:18:00 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// callable type - 호출 가능 타입
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;

void x()
{
	cout << "나는 그냥함수 x야!" << endl;
}

class Test {
public:
	void operator()(void) {
		cout << "클래스가 ()연산자를 오버로딩함" << endl;
	}
};

int main()
{
	Test t;
	t();
	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-16 오후 5:19:46 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 11일 목요일 (3주 1일)
// 
// callable type - 호출 가능 타입
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;

void x()
{
	cout << "나는 그냥함수 x야!" << endl;
}

class Test {
public:
	void operator()(void) {
		cout << "클래스가 ()연산자를 오버로딩함" << endl;
	}
};

int main()
{
	Test t;

	t(); // <- 호출가능한 타입의 갯수는 무한개다!
	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-18 오전 10:37:43 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 18일 목요일 (3주 2일)
// 
// callable type - 호출 가능 타입
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <memory>
#include <random>
#include <fstream>
#include <vector>
#include "save.h"

using namespace std;

void jump()
{
	cout << "점프" << endl;
}

void slide()
{
	cout << "슬라이드" << endl;
}

int main()
{
	void(*f)(); 
	f = jump;
	f();
	f = slide;
	f();

	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-18 오전 10:54:09 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 18일 목요일 (3주 2일)
// 
// callable type - 호출 가능 타입
//					-> STL에서는 알고리즘의 기능을 변화시킬때 사용
// 
// 함수와
// 함수객체 - function object 까지만 설명
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

using namespace std;

// 호출가능타입 종류!
// 1. 그냥 함수
// 2. 
//

class Test {
public:
	void operator()(int) {
		cout << "클래스가 오버로딩한 () 연산자로 호출하였습니다." << endl;
	}
};

void f(int)
{
	cout << "나는 일반함수 f야" << endl;
}

int main()
{

	Test t;
	f(1);
	t(2);

	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-18 오전 10:56:52 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 18일 목요일 (3주 2일)
// 
// callable type - 호출 가능 타입
//					-> STL에서는 알고리즘의 기능을 변화시킬때 사용
// 
// 함수와
// 함수객체 - function object 까지만 설명
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

using namespace std;

// 호출가능타입 종류!
// 1. 그냥 함수
// 2. 
//

class Test {
public:
	void operator()(int) {
		cout << "클래스가 오버로딩한 () 연산자로 호출하였습니다." << endl;
	}
};

void f(int)
{
	cout << "나는 일반함수 f야" << endl;
}


void (*lambda)(int) = [](int) {
	cout << "람다를 호출하였다." << endl;
};

int main()
{
	Test t;
	f(1);
	t(2);
	lambda(3);


	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-18 오전 11:02:07 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 18일 목요일 (3주 2일)
// 
// callable type - 호출 가능 타입
//					-> STL에서는 알고리즘의 기능을 변화시킬때 사용
// 
// 함수와
// 함수객체 - function object 까지만 설명
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

using namespace std;

// 호출가능타입 종류!
// 1. 그냥 함수
// 2. 
//

class Test { //클래스를 함수로 부를수 있으면 제한이 사라짐 (함수가 상태 간직 가능)
public:
	void operator()(int) {
		cout << "클래스가 오버로딩한 () 연산자로 호출하였습니다." << endl;
	}
};

void f(int)
{
	cout << "나는 일반함수 f야" << endl;
}


auto lambda = [](int) {
	cout << "람다를 호출하였다." << endl;
}; // <- 이걸 함수 포인터라고 생각하면 큰 오산! 

int main()
{
	Test t;
	f(1);
	t(2);
	lambda(3);
	cout << "람다의 정체 - " << typeid(lambda).name() << endl;

	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-18 오전 11:05:18 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 18일 목요일 (3주 2일)
// 
// callable type - 호출 가능 타입
//					-> STL에서는 알고리즘의 기능을 변화시킬때 사용
// 
// 함수와
// 함수객체 - function object 까지만 설명
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

using namespace std;

// 호출가능타입 종류!
// 1. 그냥 함수
// 2. 
//

class Test { //클래스를 함수로 부를수 있으면 제한이 사라짐 (함수가 상태 간직 가능)
public:
	void operator()(int) {
		cout << "클래스가 오버로딩한 () 연산자로 호출하였습니다." << endl;
	}
};

void f(int)
{
	cout << "나는 일반함수 f야" << endl;
}


auto lambda = [](int) {
	cout << "람다를 호출하였다." << endl;
}; 

auto lambda_1 = [](int) {
	cout << "람다1을 호출하였다." << endl;
};

int main()
{
	Test t;
	f(1);
	t(2);
	lambda(3);
	lambda_1(4);

	cout << "람다의 정체 - " << typeid(lambda).name() << endl;
	cout << "람다의 정체 - " << typeid(lambda_1).name() << endl;

	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-18 오전 11:14:35 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 18일 목요일 (3주 2일)
// 
// callable type - 호출 가능 타입
//					-> STL에서는 알고리즘의 기능을 변화시킬때 사용
// 
// 함수와
// 함수객체 - function object 까지만 설명
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

using namespace std;

// 호출가능타입 종류!
// 1. 그냥 함수
// 2. 
//

class Test { //클래스를 함수로 부를수 있으면 제한이 사라짐 (함수가 상태 간직 가능)
public:
	void operator()(int) {
		cout << "클래스가 오버로딩한 () 연산자로 호출하였습니다." << endl;
	}

	void mf(int) {
		cout << "클래스의 멤버 함수를 호출하였습니다." << endl;
	}
};

void f(int)
{
	cout << "나는 일반함수 f야" << endl;
}


auto lambda = [](int) {
	cout << "람다를 호출하였다." << endl;
}; 

auto lambda_1 = [](int) {
	cout << "람다1을 호출하였다." << endl;
};

int main()
{
	Test t;
	f(1);
	t(2);
	t.mf(5);
	
	Test k;

	void (Test::*pmf)(int) = &Test::mf;
	(k.*pmf)(1);

	lambda(3);
	lambda_1(4);

	cout << "람다의 정체 - " << typeid(lambda).name() << endl;
	cout << "람다의 정체 - " << typeid(lambda_1).name() << endl;

	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-18 오전 11:16:37 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 18일 목요일 (3주 2일)
// 
// callable type - 호출 가능 타입
//					-> STL에서는 알고리즘의 기능을 변화시킬때 사용
// 
// 함수와
// 함수객체 - function object 까지만 설명
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

using namespace std;

// 호출가능타입 종류!
// 1. 그냥 함수
// 2. 
//

class Test { //클래스를 함수로 부를수 있으면 제한이 사라짐 (함수가 상태 간직 가능)
public:
	void operator()(int) {
		cout << "클래스가 오버로딩한 () 연산자로 호출하였습니다." << endl;
	}

	void mf(int) {
		cout << "클래스의 멤버 함수를 호출하였습니다." << endl;
	}
};

void f(int)
{
	cout << "나는 일반함수 f야" << endl;
}


auto lambda = [](int) {
	cout << "람다를 호출하였다." << endl;
}; 

auto lambda_1 = [](int) {
	cout << "람다1을 호출하였다." << endl;
};

int main()
{
	Test t;
	f(1);
	t(2);
	t.mf(5);
	

	void (Test::*pmf)(int) = &Test::mf;
	(t.*pmf)(6);

	lambda(3);
	cout << "람다의 정체 - " << typeid(lambda).name() << endl;

	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-18 오전 11:18:29 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 18일 목요일 (3주 2일)
// 
// callable type - 호출 가능 타입
//					-> STL에서는 알고리즘의 기능을 변화시킬때 사용
// 
// 함수와
// 함수객체 - function object 까지만 설명
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

using namespace std;

// 호출가능타입 종류!
// 1. 그냥 함수
// 2. 
//

class Test { //클래스를 함수로 부를수 있으면 제한이 사라짐 (함수가 상태 간직 가능)
public:
	void operator()(int) {
		cout << "클래스가 오버로딩한 () 연산자로 호출하였습니다." << endl;
	}

	void mf(int) { // 모든 멤버함수의 첫번쨰 인자는 객체를 가리키는 포인터! (this)
		cout << "클래스의 멤버 함수를 호출하였습니다." << endl;
	}
};

void f(int)
{
	cout << "나는 일반함수 f야" << endl;
}


auto lambda = [](int) {
	cout << "람다를 호출하였다." << endl;
}; 

auto lambda_1 = [](int) {
	cout << "람다1을 호출하였다." << endl;
};

int main()
{
	Test t;
	f(1);
	t(2);
	t.mf(5);
	

	void (Test::*pmf)(int) = &Test::mf;
	(t.*pmf)(6);

	lambda(3);
	cout << "람다의 정체 - " << typeid(lambda).name() << endl;

	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-18 오전 11:39:28 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 18일 목요일 (3주 2일)
// 
// callable type - 호출 가능 타입
//					-> STL에서는 알고리즘의 기능을 변화시킬때 사용
// 
// C++ 에는 다양한 호출가능 타입을 통일한 function type이 있다. (매우 모호함)
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <functional>
#include "save.h"

using namespace std;

// 호출가능타입 종류!
// 1. 그냥 함수
// 2. 
//

class Test { //클래스를 함수로 부를수 있으면 제한이 사라짐 (함수가 상태 간직 가능)
public:
	void operator()(int) {
		cout << "클래스가 오버로딩한 () 연산자로 호출하였습니다." << endl;
	}
};

void f(int)
{
	cout << "나는 일반함수 f야" << endl;
}


auto lambda = [](int) {
	cout << "람다를 호출하였다." << endl;
}; 

// () <- function call operator!

int main()
{
	function<void(int)>callable_type;

	Test t;

	callable_type = f;
	callable_type(1);
	callable_type = t;
	callable_type(2);
	callable_type = lambda;
	callable_type(3);

	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-18 오후 12:07:03 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 18일 목요일 (3주 2일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

using namespace std;

// [문제] 생성 시 int num 을 인자로 받아 그 숫자만큼 메모리를 확보하고
// 메모리의 내용을 임의의 알파벳 소문자로 채우는 클래스 String을 만들어라.
// 
// main()이 문제없이 실행되도록 하라!
//



default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};

	~String() {
		delete[] k; // 소멸할거지???
	}

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for(int i = 0; i < a.num; ++i)
		os << i + 1 << "번 String 내용: "<< a.k[i] << endl;

	return os;
}

int main()
{
	String a{ 30 };
	
	cout << a << endl;
	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-18 오후 12:10:53 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 18일 목요일 (3주 2일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

using namespace std;

// [문제] 생성 시 int num 을 인자로 받아 그 숫자만큼 메모리를 확보하고
// 메모리의 내용을 임의의 알파벳 소문자로 채우는 클래스 String을 만들어라.
// 
// main()이 문제없이 실행되도록 하라!
//



default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};

	~String() {
		delete[] k; // 소멸할거지???
	}

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for(int i = 0; i < a.num; ++i)
		os << i + 1 << "번 String 내용: "<< a.k[i] << endl;

	return os;
}

int main()
{
	String a[10]{ 1,10,20,3,5,7,10,20,30,40 };
	
	for (const String& d : a)
		cout << d << endl;

	
	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-18 오후 12:11:46 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 18일 목요일 (3주 2일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

using namespace std;

// [문제] 생성 시 int num 을 인자로 받아 그 숫자만큼 메모리를 확보하고
// 메모리의 내용을 임의의 알파벳 소문자로 채우는 클래스 String을 만들어라.
// 
// main()이 문제없이 실행되도록 하라!
//



default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};

	~String() {
		delete[] k; // 소멸할거지???
	}

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for(int i = 0; i < a.num; ++i)
		os << i + 1 << "번 String 내용: "<< a.k[i] << endl;

	return os;
}

int main()
{
	String a[10]{ 1,10,20,3,5,7,10,20,30,40 };
	

	for (int i = 0; i < size(a); ++i)
		cout << a[i] << endl;

	//for (const String& d : a)
	//	cout << d << endl;

	
	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-18 오후 12:17:22 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 18일 목요일 (3주 2일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"

using namespace std;

// [문제] 생성 시 int num 을 인자로 받아 그 숫자만큼 메모리를 확보하고
// 메모리의 내용을 임의의 알파벳 소문자로 채우는 클래스 String을 만들어라.
// 
// main()이 문제없이 실행되도록 하라!
//



default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};

	~String() {
		delete[] k; // 소멸할거지???
	}

	size_t size() {
		return num;
	}

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for(int i = 0; i < a.num; ++i)
		os << i + 1 << "번 String 내용: "<< a.k[i] << endl;

	return os;
}

int main()
{
	string a[10]{ "1","10","20","3","5","7","10","20","30","40" };
	

	for (int i = 0; i < size(a); ++i)
		cout << a[i] << endl;

	sort(begin(a), end(a), [](const string& a, const string& b) {
		return a.size() < b.size();
		});

	//for (const String& d : a)
	//	cout << d << endl;

	
	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-18 오후 12:17:44 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 18일 목요일 (3주 2일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"

using namespace std;

// [문제] 생성 시 int num 을 인자로 받아 그 숫자만큼 메모리를 확보하고
// 메모리의 내용을 임의의 알파벳 소문자로 채우는 클래스 String을 만들어라.
// 
// main()이 문제없이 실행되도록 하라!
//



default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};

	~String() {
		delete[] k; // 소멸할거지???
	}

	size_t size() {
		return num;
	}

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for(int i = 0; i < a.num; ++i)
		os << i + 1 << "번 String 내용: "<< a.k[i] << endl;

	return os;
}

int main()
{
	string a[10]{ "1","10","20sdfsd","3","5","7sdfsdfsdfs","1sdfsd0","2dfd0","3sdf0","4sfsdfsdfsdf0" };
	

	for (int i = 0; i < size(a); ++i)
		cout << a[i] << endl;

	sort(begin(a), end(a), [](const string& a, const string& b) {
		return a.size() < b.size();
		});

	//for (const String& d : a)
	//	cout << d << endl;

	
	save("2021STL.cpp");
}










============================================================================================================
                            저장시간 : 2021-03-23 오후 4:09:58 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 23일 화요일 (4주 1일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"

using namespace std;
default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};

	~String() {
		delete[] k; // 소멸할거지???
	}

	size_t size() {
		return num;
	}

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for(int i = 0; i < a.num; ++i)
		os << i + 1 << "번 String 내용: "<< a.k[i] << endl;

	return os;
}

// [문제] String 배열 s를 길이 오름차순으로 정렬 후 출력하라!
//


// 뱅글리 포인터가 생겨서 죽는다.... ???
int main()
{
	String a[5]{ 10, 5, 20, 3, 7 };

	//sort(begin(a), end(a), [](const string& a, const string& b) {
	//	return a.size() < b.size();
	//	});

	for (const String& d : a)
		cout << a << endl;

	save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-03-23 오후 4:14:12 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 23일 화요일 (4주 1일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"

using namespace std;
default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};

	~String() {
		delete[] k; // 소멸할거지???
	}

	size_t size() {
		return num;
	}

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for(int i = 0; i < a.num; ++i)
		os << i + 1 << "번 String 내용: "<< a.k[i] << endl;

	return os;
}

// [문제] String 배열 s를 길이 오름차순으로 정렬 후 출력하라!
//


// 뱅글리 포인터가 생겨서 죽는다.... ???
int main()
{
	String a[5]{ 10, 5, 20, 3, 7 };

	sort(begin(a), end(a), [](String& s, String& c) {
		return s.size() < c.size();
		});

	for (const String& d : a)
		cout << a << endl;

	save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-03-23 오후 4:14:20 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 23일 화요일 (4주 1일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"

using namespace std;
default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};

	~String() {
		delete[] k; // 소멸할거지???
	}

	size_t size() {
		return num;
	}

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for(int i = 0; i < a.num; ++i)
		os << i + 1 << "번 String 내용: "<< a.k[i] << endl;

	return os;
}

// [문제] String 배열 s를 길이 오름차순으로 정렬 후 출력하라!
//


// 뱅글리 포인터가 생겨서 죽는다.... ???
int main()
{
	String a[5]{ 10, 5, 20, 3, 7 };

	sort(begin(a), end(a), [](String& s, String& c) {
		return s.size() < c.size();
		});

	for (const String& d : a)
		cout << d << endl;

	save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-03-23 오후 4:46:06 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 23일 화요일 (4주 1일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"

using namespace std;
default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};


	~String() {
		cout << "소멸" << endl;
		delete[] k; // 소멸할거지???
	}

	size_t size() const {
		return num;
	}

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for (int i = 0; i < a.num; ++i)
		os << a.k[i];

	return os;
}

// [문제] String 배열 s를 길이 오름차순으로 정렬 후 출력하라!
//


// 뱅글리 포인터가 생겨서 죽는다.... ???
int main()
{
	String s1{ 10 };

	cout << s1 << endl;

	String s2{ s1 };
	cout << s2 << endl;

	save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-03-23 오후 4:51:41 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 23일 화요일 (4주 1일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"

using namespace std;
default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};


	~String() {
		cout << "소멸" << endl;
		delete[] k; // 소멸할거지???
	}

	size_t size() const {
		return num;
	}

	String(const String&){
		cout << "복사";
	}

	String& operator=(const String&) {
		cout << "할당";
	}

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for (int i = 0; i < a.num; ++i)
		os << a.k[i];

	return os;
}

// [문제] String 배열 s를 길이 오름차순으로 정렬 후 출력하라!
//


// 뱅글리 포인터가 생겨서 죽는다.... ???
int main()
{
	save("2021STL.cpp");
	String s1{ 10 };

	cout << s1 << endl;

	String s2{ s1 };
	cout << s2 << endl;


}

============================================================================================================
                            저장시간 : 2021-03-23 오후 4:56:53 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 23일 화요일 (4주 1일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"

using namespace std;
default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};


	~String() {
		cout << "소멸" << endl;
		delete[] k; // 소멸할거지???
	}

	size_t size() const {
		return num;
	}

	String(const String& other) : num{ other.num }, k{new char[num]} {  // 깊은 복사!
		memcpy(k, other.k, num);
		//cout << "복사";
	}

	String& operator=(const String& other) {
		if (this != &other) {
			delete[] k;
			num = other.num;
			k = new char[num];
			memcpy(k, other.k, num);
		}
		//cout << "할당";
		return *this;
	}

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for (int i = 0; i < a.num; ++i)
		os << a.k[i];

	return os;
}

// [문제] String 배열 s를 길이 오름차순으로 정렬 후 출력하라!
//

int main()
{
	String s1{ 10 };

	cout << s1 << endl;

	String s2{ s1 };
	cout << s2 << endl;

	save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-03-23 오후 5:00:47 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 23일 화요일 (4주 1일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"

using namespace std;
default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};


	~String() {
		cout << "소멸" << endl;
		delete[] k; // 소멸할거지???
	}

	size_t size() const {
		return num;
	}

	String(const String& other) : num{ other.num }, k{new char[num]} {  // 깊은 복사!
		memcpy(k, other.k, num);
		//cout << "복사";
	}

	String& operator=(const String& other) {
		if (this != &other) {
			delete[] k;
			num = other.num;
			k = new char[num];
			memcpy(k, other.k, num);
		}
		//cout << "할당";
		return *this;
	}

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for (int i = 0; i < a.num; ++i)
		os << a.k[i];

	return os;
}



// [문제] String을 10개 만들고 길이 내림차순으로 정렬 후 출력하라!
int main()
{
	String s[10]{ 10, 30, 50, 70, 90, 20, 40, 60, 80, 3 };

	sort(begin(s), end(s), [](const String& a, const String& b) {return a.size() > b.size(); });

	for (String s : s)
		cout << s << endl;

	save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-03-23 오후 5:01:02 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 23일 화요일 (4주 1일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"

using namespace std;
default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};


	~String() {
		delete[] k; // 소멸할거지???
	}

	size_t size() const {
		return num;
	}

	String(const String& other) : num{ other.num }, k{new char[num]} {  // 깊은 복사!
		memcpy(k, other.k, num);
		//cout << "복사";
	}

	String& operator=(const String& other) {
		if (this != &other) {
			delete[] k;
			num = other.num;
			k = new char[num];
			memcpy(k, other.k, num);
		}
		//cout << "할당";
		return *this;
	}

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for (int i = 0; i < a.num; ++i)
		os << a.k[i];

	return os;
}



// [문제] String을 10개 만들고 길이 내림차순으로 정렬 후 출력하라!
int main()
{
	String s[10]{ 10, 30, 50, 70, 90, 20, 40, 60, 80, 3 };

	sort(begin(s), end(s), [](const String& a, const String& b) {return a.size() > b.size(); });

	for (String s : s)
		cout << s << endl;

	save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-03-23 오후 5:05:03 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 23일 화요일 (4주 1일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"

using namespace std;
default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};


	~String() {
		delete[] k; // 소멸할거지???
	}

	size_t size() const {
		return num;
	}

	String(const String& other) : num{ other.num }, k{new char[num]} {  // 깊은 복사!
		memcpy(k, other.k, num);
		//cout << "복사";
	}

	String& operator=(const String& other) {
		if (this != &other) {
			delete[] k;
			num = other.num;
			k = new char[num];
			memcpy(k, other.k, num);
		}
		//cout << "할당";
		return *this;
	}

	String(String&&) = default;
	String& operator=(String&&) = default;

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for (int i = 0; i < a.num; ++i)
		os << a.k[i];

	return os;
}



// [문제] String을 10개 만들고 길이 내림차순으로 정렬 후 출력하라!
int main()
{
	String s[10]{ 10, 30, 50, 70, 90, 20, 40, 60, 80, 3 };

	sort(begin(s), end(s), [](const String& a, const String& b) {return a.size() > b.size(); });

	for (const String& s : s)
		cout << s << endl;

	save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-03-23 오후 5:07:24 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 23일 화요일 (4주 1일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include <string>
#include "save.h"

using namespace std;
default_random_engine dre;

class String {
private:
	int num;
	char* k{ nullptr };
public:
	String(int n) : num{ n }, k{new char[num]} {
		uniform_int_distribution<> uid('a', 'z');
		for (int i = 0; i < num; ++i)
			k[i] = uid(dre);
	};


	~String() {
		delete[] k; // 소멸할거지???
	}

	size_t size() const {
		return num;
	}

	String(const String& other) : num{ other.num }, k{new char[num]} {  // 깊은 복사!
		memcpy(k, other.k, num);
		//cout << "복사";
	}

	String& operator=(const String& other) {
		if (this != &other) {
			delete[] k;
			num = other.num;
			k = new char[num];
			memcpy(k, other.k, num);
		}
		//cout << "할당";
		return *this;
	}

	String(String&&) { cout << "이동" << endl;; }
	String& operator=(String&&) { 
		cout << "이동 할당" << endl;
		return *this; 
	}

	friend ostream& operator<<(ostream& os, const String& a);
};

ostream& operator<<(ostream& os, const String& a)
{
	for (int i = 0; i < a.num; ++i)
		os << a.k[i];

	return os;
}



// [문제] String을 10개 만들고 길이 내림차순으로 정렬 후 출력하라!
int main()
{
	String s[10]{ 10, 30, 50, 70, 90, 20, 40, 60, 80, 3 };

	sort(begin(s), end(s), [](const String& a, const String& b) {return a.size() > b.size(); });

	for (const String& d : s)
		cout << d << endl;

	save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-03-23 오후 5:18:43 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 23일 화요일 (4주 1일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
// - sort의 기본 이동연산을 확인해야 함
// 
//  다음 시간 - 파일 분리
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <iterator>
#include <fstream>
#include <algorithm>
#include "save.h"

using namespace std;




// [문제] 사용자가 원하는 모든 단어를 입력받은 후
// 오름차순으로 정렬하여 출력하라.

int main()
{
	vector<string> v{ istream_iterator<string>{cin}, {} };
	
	sort(v.begin(), v.end());
	
	copy(v.begin(), v.end(), ostream_iterator<string>{cout, "\t"});
	
	save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-03-23 오후 5:19:10 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 23일 화요일 (4주 1일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
// - sort의 기본 이동연산을 확인해야 함
// 
//  다음 시간 - 파일 분리
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <iterator>
#include <fstream>
#include <algorithm>
#include "save.h"

using namespace std;




// [문제] 사용자가 원하는 모든 단어를 입력받은 후
// 오름차순으로 정렬하여 출력하라.

int main()
{
	vector<string> v{ istream_iterator<string>{cin}, {} };
	
	sort(v.begin(), v.end());
	
	copy(v.begin(), v.end(), ostream_iterator<string>{cout, "\t"});
	
	save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-03-23 오후 5:21:01 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 23일 화요일 (4주 1일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
// - sort의 기본 이동연산을 확인해야 함
// 
//  다음 시간 - 파일 분리
//------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <iterator>
#include <fstream>
#include <algorithm>
#include <fstream>
#include "save.h"

using namespace std;




// [문제] 사용자가 원하는 모든 단어를 입력받은 후
// 오름차순으로 정렬하여 출력하라.

int main()
{
	ifstream in{ "2021_1학기_STL(화78,목23)_강의저장.txt" };
	vector<string> v{ istream_iterator<string>{in}, {} };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>{cout, "\t"});
	save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-03-25 오전 11:49:28 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 25일 화요일 (4주 2일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
// - sort의 기본 이동연산을 확인해야 함
// 
//  다음 시간 - 파일 분리
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"

using namespace std;

default_random_engine dre;
uniform_int_distribution<>uid{ 'a','z' };

class String
{
private:
    size_t num;
    char* p;

public:
    String(int _num) :num{ (size_t)_num }, p{ new char[num] } {
        for (int i = 0; i < num; ++i)
            p[i] = uid(dre);
    };

    //이동생성자
    String(String&& other) : num{ other.num } {
        cout << "이동생성자!" << endl;
        p = other.p;
        other.p = nullptr;
        other.num = 0;
    }

    //이동할당연산자
    String& operator=(String&& other) {
        cout << "이동할당연산자!" << endl;
        if (this != &other) {
            num = other.num;
            p = other.p;
            other.p = nullptr;
        }
        return *this;
    }



    //복사생성자
    String(const String& _other) :num{ _other.num }, p{ new char[num] }{
        cout << "복사생성자!" << endl;
        memcpy(p, _other.p, num);
    }

    //복사할당연산자
    String& operator=(const String& _other) {
        cout << "복사할당연산자!" << endl;
        if (this != &_other)
        {
            this->~String();
            num = _other.num;
            p = new char[num];
            memcpy(p, _other.p, num);
        }
        //자원을 반환
        return *this;
    }

    friend ostream& operator<<(ostream& os, const String& s);
    
    // 저장하고 있는 글자수를 알려주자
    size_t size() const {
        return num;
    }
   
    ~String()
    {
        cout << (void*)p << " 삭제" << endl;
        delete[] p;
    };
};

ostream& operator<<(ostream& os, const String& s)
{
    for (int i = 0; i < s.num; ++i)
    {
        cout << s.p[i];
    }

    return os;
}


//[문제] 알고리즘 sort가 객체를 어떻게 이용하는지 살펴본다.
//
int main()
{
    String s[3]{ 10,30,20 };

    //길이 오름차순으로 정렬하라!
    sort(begin(s), end(s), [](const String& a, const String& b) {
        return a.size() < b.size();
        });

    for (int i = 0; i < 3; ++i)
        cout << s[i] << endl;

    save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-25 오전 11:50:07 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 25일 화요일 (4주 2일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
// - sort의 기본 이동연산을 확인해야 함
// 
//  다음 시간 - 파일 분리
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"

using namespace std;

default_random_engine dre;
uniform_int_distribution<>uid{ 'a','z' };

class String
{
private:
    size_t num;
    char* p;

public:
    String(int _num) :num{ (size_t)_num }, p{ new char[num] } {
        for (int i = 0; i < num; ++i)
            p[i] = uid(dre);
    };

    //이동생성자


    //이동할당연산자
    String& operator=(String&& other) {
        cout << "이동할당연산자!" << endl;
        if (this != &other) {
            num = other.num;
            p = other.p;
            other.p = nullptr;
        }
        return *this;
    }



    //복사생성자
    String(const String& _other) :num{ _other.num }, p{ new char[num] }{
        cout << "복사생성자!" << endl;
        memcpy(p, _other.p, num);
    }

    //복사할당연산자
    String& operator=(const String& _other) {
        cout << "복사할당연산자!" << endl;
        if (this != &_other)
        {
            this->~String();
            num = _other.num;
            p = new char[num];
            memcpy(p, _other.p, num);
        }
        //자원을 반환
        return *this;
    }

    friend ostream& operator<<(ostream& os, const String& s);
    
    // 저장하고 있는 글자수를 알려주자
    size_t size() const {
        return num;
    }
   
    ~String()
    {
        cout << (void*)p << " 삭제" << endl;
        delete[] p;
    };
};

ostream& operator<<(ostream& os, const String& s)
{
    for (int i = 0; i < s.num; ++i)
    {
        cout << s.p[i];
    }

    return os;
}


//[문제] 알고리즘 sort가 객체를 어떻게 이용하는지 살펴본다.
//
int main()
{
    String s[3]{ 10,30,20 };

    //길이 오름차순으로 정렬하라!
    sort(begin(s), end(s), [](const String& a, const String& b) {
        return a.size() < b.size();
        });

    for (int i = 0; i < 3; ++i)
        cout << s[i] << endl;

    save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-25 오전 11:52:16 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 25일 화요일 (4주 2일)
// 
// STL의 내부를 관찰할 수 있는 자원을 확보하는 클래스를 만든다.
// - sort의 기본 이동연산을 확인해야 함
// 
//  다음 시간 - 파일 분리
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"

using namespace std;

default_random_engine dre;
uniform_int_distribution<>uid{ 'a','z' };

class String
{
private:
    size_t num;
    char* p;

public:
    String(int _num) :num{ (size_t)_num }, p{ new char[num] } {
        for (int i = 0; i < num; ++i)
            p[i] = uid(dre);
    };

    //이동생성자
    String(String&& other) noexcept : num{ other.num } {
        cout << "이동생성자!" << endl;
        p = other.p;
        other.p = nullptr;
        other.num = 0;
    }

    //이동할당연산자
    String& operator=(String&& other) noexcept {
        cout << "이동할당연산자!" << endl;
        if (this != &other) {
            num = other.num;
            p = other.p;
            other.p = nullptr;
        }
        return *this;
    }



    //복사생성자
    String(const String& _other) :num{ _other.num }, p{ new char[num] }{
        cout << "복사생성자!" << endl;
        memcpy(p, _other.p, num);
    }

    //복사할당연산자
    String& operator=(const String& _other) {
        cout << "복사할당연산자!" << endl;
        if (this != &_other)
        {
            this->~String();
            num = _other.num;
            p = new char[num];
            memcpy(p, _other.p, num);
        }
        //자원을 반환
        return *this;
    }

    friend ostream& operator<<(ostream& os, const String& s);
    
    // 저장하고 있는 글자수를 알려주자
    size_t size() const {
        return num;
    }
   
    ~String()
    {
        cout << (void*)p << " 삭제" << endl;
        delete[] p;
    };
};

ostream& operator<<(ostream& os, const String& s)
{
    for (int i = 0; i < s.num; ++i)
    {
        cout << s.p[i];
    }

    return os;
}


//[문제] 알고리즘 sort가 객체를 어떻게 이용하는지 살펴본다.
//
int main()
{
    String s[3]{ 10,30,20 };

    //길이 오름차순으로 정렬하라!
    sort(begin(s), end(s), [](const String& a, const String& b) {
        return a.size() < b.size();
        });

    for (int i = 0; i < 3; ++i)
        cout << s[i] << endl;

    save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-30 오후 4:10:49 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 30일 화요일 (5주 1일)
// 
// 
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "String.h"

using namespace std;

String s{ 20 };
int main()
{

	int n{ 123 };

	cout << "main의 번지는 : " << main << endl;
	cout << "n은 지역변수 입니다. 위치는 : " << &n << endl;
	cout << s << endl;
	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-30 오후 4:19:51 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 30일 화요일 (5주 1일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "String.h"

using namespace std;

int main()
{
	array<String, 3> words{ 20,10,30 };

	for (auto p = words.begin(); p != words.end(); ++p)
		cout << *p << endl;

	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-30 오후 4:41:23 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 30일 화요일 (5주 1일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;

int main()
{
	array<String, 3> words{ 20,10,30 };


	// 길이 오름차순으로 정렬하시오.
	sort(words.begin(), words.end(), [](const String&a, const String& b) {
		return a.size() < b.size();
		});

	for (auto p = words.begin(); p != words.end(); ++p)
		cout << *p << endl;

	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-30 오후 4:53:15 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 30일 화요일 (5주 1일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;

int main()
{
	array<int, 10> a;
	
	cout << "관리하는 원소 갯수 - " << a.size() << endl;
	// [문제] 지역객체 a의 메모리 크기는? -> 40byte!!

	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-30 오후 4:53:58 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 30일 화요일 (5주 1일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;

int main()
{
	array<int, 10> a;
	cout << "관리하는 원소 갯수 - " << a.size() << endl;
	// [문제] 지역객체 a의 메모리 크기는? -> 40byte!!
	
	array<int, 100> b;
	cout << "관리하는 원소 갯수 - " << a.size() << endl;
	// [문제] 지역객체 a,b의 메모리 크기를 출력하라!

	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-30 오후 4:55:14 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 30일 화요일 (5주 1일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;

int main()
{
	array<int, 1'000'000> a;
	cout << "관리하는 원소 갯수 - " << a.size() << endl;
	// [문제] 지역객체 a의 메모리 크기는? -> 40byte!!
	
	array<int, 100> b;
	cout << "관리하는 원소 갯수 - " << a.size() << endl;
	// [문제] 지역객체 a,b의 메모리 크기를 출력하라! -> 400byte!!

	//[진짜 질문] 지역객체 a는 몆개의 int를 담을 수 있는가?

	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-30 오후 4:55:28 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 30일 화요일 (5주 1일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;

int main()
{
	array<int, 1'000'000> a;
	cout << "관리하는 원소 갯수 - " << a.size() << endl;
	// [문제] 지역객체 a의 메모리 크기는? -> 40byte!!
	
	array<int, 100> b;
	cout << "관리하는 원소 갯수 - " << b.size() << endl;
	// [문제] 지역객체 a,b의 메모리 크기를 출력하라! -> 400byte!!

	//[진짜 질문] 지역객체 a는 몆개의 int를 담을 수 있는가?

	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-03-30 오후 4:58:22 화요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 -		3월 30일 화요일 (5주 1일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;

int main()
{
	array<int, 200'000> a{ 0 };
	cout << "관리하는 원소 갯수 - " << a.size() << endl;
	// [문제] 지역객체 a의 메모리 크기는? -> 40byte!!
	
	for (int& n : a)
		n = 12345678;



	array<int, 100> b;
	cout << "관리하는 원소 갯수 - " << b.size() << endl;
	// [문제] 지역객체 a,b의 메모리 크기를 출력하라! -> 400byte!!

	//[진짜 질문] 지역객체 a는 몆개의 int를 담을 수 있는가? (스택 크기만큼 넣을수 있다!!!)

	save("2021STL.cpp");
}


============================================================================================================
                            저장시간 : 2021-04-01 오전 10:32:17 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;

template<typename T, int N>
class Array {
public:
    Array() {};

    int size() {
        return N;
    }

    T& operator[](int index) {
        return d[index];
    }

    T* begin() {
        return d;
    }

    T* end() {
        return &d[N];
    }

private:
    T d[N];
};


// [문제] 


int main()
{
    Array<int, 10> a;
    // 10개에 값을 쓴다.

    for (int i = 0; i < a.size(); ++i)
        a[i] = 9 - i;

    cout << "정렬 전 - ";
    for (int i = 0; i < a.size(); ++i)
        cout << a[i] << " ";
    cout << endl;

    sort(a.begin(), a.end());  //ascending order

    cout << "정렬 후 - ";
    for (auto p = a.begin(); p != a.end(); ++p)
        cout << *p << " ";
    cout << endl;

    save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오전 10:47:01 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;

template<typename T, size_t N>
class Array {
public:
    Array() {};

    size_t size() const{
        return N;
    }

    //T& operator[](int index) { // 이건 내가만든 코드
    //    return d[index];
    //}

    T& operator[](int index) {  // 이건 교수님 코드
        return *(d + index);
    }

    T* begin() {
        return d;
    }

    T* end() {
        return &d[N];
    }

private:
    T d[N]{};
};


int main()
{
    Array<int, 10> a;
    // 10개에 값을 쓴다.

    for (int i = 0; i < a.size(); ++i)
        a[i] = -i;

    cout << "정렬 전 - ";
    for (int i = 0; i < a.size(); ++i)
        cout << a[i] << " ";
    cout << endl;

    sort(a.begin(), a.end());  //ascending order

    cout << "정렬 후 - ";
    for (auto p = a.begin(); p != a.end(); ++p)
        cout << *p << " ";
    cout << endl;

    save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오전 10:55:36 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;

template<typename T, size_t N>
class Array {
public:
    Array() {}; // { } <- 이건 전부 0으로 만들어준다는걸 보장함! {0}이건 하나만 됨

    size_t size() const{
        return N;
    }

    //T& operator[](int index) { // 이건 내가만든 코드
    //    return d[index];
    //}
    T operator[](int index) const {  // 이건 값을 넣을때가 아닌 읽기용!
        cout << "읽기버전 호출" << endl;
        return *(d + index);
    }

    T& operator[](int index) {  // 이건 교수님 코드
        cout << "쓰기버전 호출" << endl;
        return *(d + index);
    }

    T* begin() {
        return d;
    }

    T* end() {  // 이건 내 코드
        return &d[N];
    }

    //T* end() {  // 이건 교수님 코드
    //    return d + N;
    //}

private:
    T d[N]{};
};


int main()
{
    Array<int, 10> a;
    // 10개에 값을 쓴다.

    for (int i = 0; i < a.size(); ++i)
        a[i] = -i;

    cout << "정렬 전 - ";
    for (int i = 0; i < a.size(); ++i)
        cout << a[i] << " ";
    cout << endl;

    sort(a.begin(), a.end());  //ascending order

    cout << "정렬 후 - ";
    for (auto p = a.begin(); p != a.end(); ++p)
        cout << *p << " ";
    cout << endl;

    save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오전 10:58:32 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;

template<typename T, size_t N>
class Array {
public:
    Array() {}; // { } <- 이건 전부 0으로 만들어준다는걸 보장함! {0}이건 하나만 됨

    size_t size() const{
        return N;
    }

    //T& operator[](int index) { // 이건 내가만든 코드
    //    return d[index];
    //}
    T operator[](int index) const {  // 이건 값을 넣을때가 아닌 읽기용!
        return *(d + index);
    }

    T& operator[](int index) {  // 이건 교수님 코드
        return *(d + index);
    }

    T* begin() {
        return d;
    }

    T* end() {  // 이건 내 코드
        return &d[N];
    }

    //T* end() {  // 이건 교수님 코드
    //    return d + N;
    //}

private:
    T d[N]{};
};


int main()
{
    array<int, 10> a{ 10,8,6,4,2,9,7,5,3,1 };
    // 10개에 값을 쓴다.

    //for (int i = 0; i < a.size(); ++i)
    //    a[i] = -i;

    cout << "정렬 전 - ";
    for (int i = 0; i < a.size(); ++i)
        cout << a[i] << " ";
    cout << endl;

    sort(a.begin(), a.end());  //ascending order

    cout << "정렬 후 - ";
    for (auto p = a.begin(); p != a.end(); ++p)
        cout << *p << " ";
    cout << endl;

    save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오전 11:00:26 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;

template<typename T, size_t N>
class Array {
public:
    Array() {}; // { } <- 이건 전부 0으로 만들어준다는걸 보장함! {0}이건 하나만 됨

    size_t size() const{
        return N;
    }

    //T& operator[](int index) { // 이건 내가만든 코드
    //    return d[index];
    //}
    T operator[](int index) const {  // 이건 값을 넣을때가 아닌 읽기용!
        return *(d + index);
    }

    T& operator[](int index) {  // 이건 교수님 코드
        return *(d + index);
    }

    T* begin() {
        return d;
    }

    T* end() {  // 이건 내 코드
        return &d[N];
    }

    //T* end() {  // 이건 교수님 코드
    //    return d + N;
    //}

private:
    T d[N]{};
};


int main()
{
    array<int, 10> a{ 10,8,6,4,2,9,7,5,3,1 };
    // 10개에 값을 쓴다.

    //for (int i = 0; i < a.size(); ++i)
    //    a[i] = -i;

    cout << "정렬 전 - ";
    for (int i = 0; i < a.size(); ++i)
        cout << a[i] << " ";
    cout << endl;

    sort(a.begin(), a.begin() + 5);  //ascending order

    cout << "정렬 후 - ";
    for (auto p = a.begin(); p != a.end(); ++p)
        cout << *p << " ";
    cout << endl;

    save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오전 11:18:10 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;
int n = 456;
int main()
{
    array<String, 1>a{ 10 };

    int n{ 123 };

    cout << "이동네는 STACK - " << &n << endl;
    cout << "이동네는 DATA - " << &::n << endl;

    save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오전 11:19:31 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;
int n = 456;
int main()
{
    array<String, 1>a{ 10 };

    int n{ 123 };
    
    cout << "이동네는 STACK - " << &n << endl;
    cout << "이동네는 DATA - " << &::n << endl;
    int *p = new int;
    cout << "이동네는 Free store - " << p << endl;
    cout << "이동네는 CODE - " << main << endl;
    save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오전 11:43:12 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
//  STL Sequence 컨테이너
// - array
// - vector
// - deque
// - foward_list
// - list
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"

using namespace std;


// [질문] []가 있는데 array<T,N>은 왜 만들었나?
//
// 이유?? - 속도나 메모리면에서는 동일하다!
//        - 스마트한 배열!
//        - 사용할수 있는 부가정보가 많다.
//        - 기능이 많은데 사용 안할 이유가 없다..
int a[100];
array<int, 100>b;
int main()
{
    
    save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오후 12:00:22 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
// - 벡터는 dynamic(프로그램이 실행될 때 크기가 변하는) arrays. (vector!!) 크기가 가변하는!
//                    -> 크기가 제 멋대로 변하는 배열 입니다.
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"

using namespace std;


// [문제] int를 입력받아 합계와 평균을 구하시오.
//
int main()
{
    vector<int> v;
    int num;
    cout << "숫자를 입력하고 끝내려면 ctrl + z를 누르세요." << endl;
    while (cin >> num) {
        v.push_back(num);
    }

    int total = 0;

    for (int n : v)
        total += n;

    cout << "합계 : " << total << ", 평균 : " << total / v.size() << endl;
        
   save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오후 12:01:55 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
// - 벡터는 dynamic(프로그램이 실행될 때 크기가 변하는) arrays. (vector!!) 크기가 가변하는!
//                    -> 크기가 제 멋대로 변하는 배열 입니다.
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"

using namespace std;


// [문제] int를 입력받아 합계와 평균을 구하시오.
//
int main()
{
    vector<int> v;
    int num;
    cout << "숫자를 입력하고 끝내려면 ctrl + z를 누르세요." << endl;
    while (cin >> num) {
        v.push_back(num);
    }

    int total{};

    for (int n : v)
        total += n;

    cout << "합계 : " << total << ", 평균 : " << static_cast<double>(total) / v.size() << endl;
        
   save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오후 12:02:46 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
// - 벡터는 dynamic(프로그램이 실행될 때 크기가 변하는) arrays. (vector!!) 크기가 가변하는!
//                    -> 크기가 제 멋대로 변하는 배열 입니다.
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"

using namespace std;


// [문제] int를 입력받아 합계와 평균을 구하시오.
//
int main()
{
    vector<int> v;
    int num;
    cout << "숫자를 입력하고 끝내려면 ctrl + z를 누르세요." << endl;
    while (cin >> num) {
        v.push_back(num);
    }

    int total{};

    for (int n : v)
        total += n;

    cout << "합계 : " << total << ", 평균 : " << static_cast<double>(total) / v.size() << endl;
        
   save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오후 12:03:54 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
// - 벡터는 dynamic(프로그램이 실행될 때 크기가 변하는) arrays. (vector!!) 크기가 가변하는!
//                    -> 크기가 제 멋대로 변하는 배열 입니다.
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"

using namespace std;


// [문제] int를 입력받아 합계와 평균을 구하시오.
//
int main()
{
    vector<int> v; // v의 메모리 크기는?

    cout << sizeof(v) << endl;
        
   save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오후 12:04:03 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
// - 벡터는 dynamic(프로그램이 실행될 때 크기가 변하는) arrays. (vector!!) 크기가 가변하는!
//                    -> 크기가 제 멋대로 변하는 배열 입니다.
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"

using namespace std;


// [문제] int를 입력받아 합계와 평균을 구하시오.
//
int main()
{
    vector<int> v; // v의 메모리 크기는? 12!

    cout << sizeof(v) << endl;
        
   save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오후 12:05:31 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
// - 벡터는 dynamic(프로그램이 실행될 때 크기가 변하는) arrays. (vector!!) 크기가 가변하는!
//                    -> 크기가 제 멋대로 변하는 배열 입니다.
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"

using namespace std;


// [문제] int를 입력받아 합계와 평균을 구하시오.
//
int main()
{
    vector<int> v{ 1,2,3,4,5,6,7,8,9,10 }; // 이떄의 v의 크기는?

    cout << sizeof(v) << endl;
        
   save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오후 12:06:28 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
// - 벡터는 dynamic(프로그램이 실행될 때 크기가 변하는) arrays. (vector!!) 크기가 가변하는!
//                    -> 크기가 제 멋대로 변하는 배열 입니다.
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"

using namespace std;


// [문제] int를 입력받아 합계와 평균을 구하시오.
//
int main()
{
    vector<int> v{ 1,2,3,4,5,6,7,8,9,10 }; // 이떄의 v의 크기는? 12로 똑같다!!


    cout << sizeof(v) << endl;
        
   save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오후 12:11:55 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
// - 벡터는 dynamic(프로그램이 실행될 때 크기가 변하는) arrays. (vector!!) 크기가 가변하는!
//                    -> 크기가 제 멋대로 변하는 배열 입니다.
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"

using namespace std;


// [문제] int를 입력받아 합계와 평균을 구하시오.
//
int main()
{
    vector<int> v{ 10,20,30 };

    void* p = &v;
    int* ip = (int*)p;

    cout << "v의 필드 1 - " << *ip << endl;
    ++ip;
    cout << "v의 필드 2 - " << *ip << endl;
    ++ip;
    cout << "v의 필드 3 - " << *ip << endl;
        
   save("2021STL.cpp");
}



============================================================================================================
                            저장시간 : 2021-04-01 오후 12:15:23 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
// - 벡터는 dynamic(프로그램이 실행될 때 크기가 변하는) arrays. (vector!!) 크기가 가변하는!
//                    -> 크기가 제 멋대로 변하는 배열 입니다.
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"

using namespace std;


// [문제] 벡터 메모리 주소를 받아서 사이즈가 3인걸 출력해보고 싶다.
//
int main()
{
    vector<int> v{ 10,20,30 };

    void* p = &v;
    int* ip = (int*)p;

    cout << "v의 필드 1 - " << &ip << endl;
    ++ip;
    cout << "v의 필드 2 - " << &ip << endl;
    ++ip;
    cout << "v의 필드 3 - " << &ip << endl;
        
   save("2021STL.cpp");
}

============================================================================================================
                            저장시간 : 2021-04-01 오후 12:16:21 목요일
============================================================================================================
//------------------------------------------------------------------------------------------------------------
// 2021. 1학기 STL 화78 목23 - 4월 1일 목요일 (5주 2일)
// 
// - 벡터는 dynamic(프로그램이 실행될 때 크기가 변하는) arrays. (vector!!) 크기가 가변하는!
//                    -> 크기가 제 멋대로 변하는 배열 입니다.
//------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"

using namespace std;


// [문제] 벡터 메모리 주소를 받아서 사이즈가 3인걸 출력해보고 싶다.
//
int main()
{
    vector<int> v{ 10,20,30 };

    void* p = &v;
    int* ip = (int*)p;

    cout << "v의 필드 1 - " << *ip << endl;
    ip += 3;
    cout << "v의 필드 2 - " << *ip << endl;
    ip += 3;
    cout << "v의 필드 3 - " << *ip << endl;
        
   save("2021STL.cpp");
}